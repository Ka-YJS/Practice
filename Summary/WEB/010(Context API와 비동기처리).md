# Context API

1. 개념
    - React에서 컴포넌트 간의 전역 상태를 관리하고 데이터를 공유하기 위한 내장 기능
    - 컴포넌트 트리의 최상위에서 데이터를 제공(Provider)하고, 하위 컴포넌트에서 해당 데이터를 소비(Consumer)할 수 있음
    - 컴포넌트 트리의 여러 단계에 걸쳐 데이터를 전달해야 할 때, 즉 Props Drilling(프롭스 드릴링) 문제를 해결하는 데 유용함
2. Props Drilling(프롭스 드릴링)
    - 상위 컴포넌트에서 하위 컴포넌트로 데이터를 전달할 때, 여러 단계의 컴포넌트를 거쳐야 하는 문제(상황)를(을) 말함
    - 이는 코드의 가독성을 떨어뜨리고, 유지보수를 어렵게 만들 수 있음
3. 왜 Context API를 사용해야 하는가
    - 전역 상태 관리
        1. 애플리케이션에서 전역으로 사용되는 상태를 관리할 수 있음
        2. 예를 들어, 사용자 인증 정보, 테마 설정, 언어 설정 등을 전역 상태로 관리할 수 있음
    - Props Drilling 문제 해결 : 상위 컴포넌트에서 하위 컴포넌트로 데이터를 전달할 때, 여러 중간 컴포넌트를 거쳐야 하는 문제를 해결할 수 있음

## Context API 용어정리

1. createContext()
    - 데이터를 공유할 Context를 생성함
    - Context는 React 컴포넌트를 하위로 전달할 수 있는 수단임
2. UserContext
    - createContext( )로 생성된 Context 객체를 저장하는 변수임
    - 이 객체는 데이터를 제공(Provider)하거나, 데이터를 소비(Consumer)할 수 있는 기능을 제공함
    - UserContext.Provider: 데이터를 제공하는 컴포넌트로 사용됨
    - UserContext.Consumer 또는 useContext(UserContext): 데이터를 소비하는 컴포넌트에서 사용함
3. UserProvider
    - Context의 Provider 역할을 함
    - 즉, 이 컴포넌트를 사용하면 하위 컴포넌트에서 UserContext의 데이터를 사용할 수 있음
4. <UserContext.Provider \/> : Provider는 Context에서 제공하는 특수한 컴포넌트로, 하위 컴포넌트들에게 전역 상태를 전달하는 역할을 함
5. value
    - Provider가 하위 컴포넌트들에게 제공할 데이터를 정의함
    - 여기서는 { user, setUser }라는 객체를 제공하여, 사용자 정보를 가져오거나 변경할 수 있게 함
6. {children}
    - UserProvider 컴포넌트가 감싸고 있는 모든 하위 컴포넌트들을 의미함
    - 이 children들은 UserContext.Provider로부터 전달된 데이터를 사용할 수 있음


# 비동기처리

1. 작업이 시작된 후 즉시 결과를 기다리지 않고, 다른 작업을 계속할 수 있는 프로그래밍 방식임
2. 주로 네트워크 요청(API 호출), 파일 읽기, 타이머 등 시간이 오래 걸릴 수 있는 작업을 처리할 때 사용됨
3. 이 방식은 작업이 완료될 때까지 애플리케이션이 멈추지 않고, 다른 코드나 작업을 계속해서 실행할 수 있게 해줌
4. 동기처리(Synchronous)
```JS
	console.log('첫 번째 작업 시작');
	const result = performHeavyTask(); // 무거운 작업 실행 (예: API 호출)
	console.log('첫 번째 작업 완료:', result);
	console.log('다음 작업 진행');
```
- 한 번에 하나의 작업만 처리되며, 작업이 완료될 때까지 다음 작업을 진행할 수 없음
- 여기서 **performHeavyTask()**가 완료될 때까지 프로그램은 멈춰서 기다림
- 그다음 작업은 무거운 작업이 완료된 후에야 실행됨
5. 비동기처리(Asynchronous)
```JS
	console.log('첫 번째 작업 시작');
	setTimeout(() => {
	  console.log('첫 번째 작업 완료');
	}, 2000); // 2초 후에 실행
	console.log('다음 작업 진행');
```
- 작업이 완료되기를 기다리지 않고, 다른 작업을 동시에 진행할 수 있음
- 결과가 준비되면, 그 시점에 맞춰 특정 작업을 처리할 수 있도록 함
- 비동기 처리는 콜백 함수, Promise, async/await 같은 구조로 처리됨
- 위 코드에서 setTimeout은 비동기적으로 실행되며, 2초가 지나야 실행됨
- 그러나 **'다음 작업 진행'**은 즉시 실행됨
- 즉, 프로그램은 멈추지 않고, 타이머가 끝나는 동안 다른 작업을 처리함
6. 비동기 처리가 중요한 이유
    - 주로 시간이 오래 걸리는 작업(예: 네트워크 요청, 파일 읽기/쓰기, 타이머 등)을 처리할 때 유용
    - 만약 이런 작업을 동기 방식으로 처리한다면, 작업이 완료될 때까지 애플리케이션이 멈추게 되어 사용자 경험이 매우 나빠질 수 있음
    - 비동기 처리를 사용하면, 작업이 완료될 때까지 기다리는 동안에도 UI가 반응하고 다른 작업이 실행될 수 있음