# Context API

1. 개념
    - React에서 컴포넌트 간의 전역 상태를 관리하고 데이터를 공유하기 위한 내장 기능
    - 컴포넌트 트리의 최상위에서 데이터를 제공(Provider)하고, 하위 컴포넌트에서 해당 데이터를 소비(Consumer)할 수 있음
    - 컴포넌트 트리의 여러 단계에 걸쳐 데이터를 전달해야 할 때, 즉 Props Drilling(프롭스 드릴링) 문제를 해결하는 데 유용함
2. Props Drilling(프롭스 드릴링)
    - 상위 컴포넌트에서 하위 컴포넌트로 데이터를 전달할 때, 여러 단계의 컴포넌트를 거쳐야 하는 문제(상황)를(을) 말함
    - 이는 코드의 가독성을 떨어뜨리고, 유지보수를 어렵게 만들 수 있음
3. 왜 Context API를 사용해야 하는가
    - 전역 상태 관리
        1. 애플리케이션에서 전역으로 사용되는 상태를 관리할 수 있음
        2. 예를 들어, 사용자 인증 정보, 테마 설정, 언어 설정 등을 전역 상태로 관리할 수 있음
    - Props Drilling 문제 해결 : 상위 컴포넌트에서 하위 컴포넌트로 데이터를 전달할 때, 여러 중간 컴포넌트를 거쳐야 하는 문제를 해결할 수 있음

## Context API 용어정리

1. createContext()
    - 데이터를 공유할 Context를 생성함
    - Context는 React 컴포넌트를 하위로 전달할 수 있는 수단임
2. UserContext
    - createContext( )로 생성된 Context 객체를 저장하는 변수임
    - 이 객체는 데이터를 제공(Provider)하거나, 데이터를 소비(Consumer)할 수 있는 기능을 제공함
    - UserContext.Provider: 데이터를 제공하는 컴포넌트로 사용됨
    - UserContext.Consumer 또는 useContext(UserContext): 데이터를 소비하는 컴포넌트에서 사용함
3. UserProvider
    - Context의 Provider 역할을 함
    - 즉, 이 컴포넌트를 사용하면 하위 컴포넌트에서 UserContext의 데이터를 사용할 수 있음
4. <UserContext.Provider \/> : Provider는 Context에서 제공하는 특수한 컴포넌트로, 하위 컴포넌트들에게 전역 상태를 전달하는 역할을 함
5. value
    - Provider가 하위 컴포넌트들에게 제공할 데이터를 정의함
    - 여기서는 { user, setUser }라는 객체를 제공하여, 사용자 정보를 가져오거나 변경할 수 있게 함
6. {children}
    - UserProvider 컴포넌트가 감싸고 있는 모든 하위 컴포넌트들을 의미함
    - 이 children들은 UserContext.Provider로부터 전달된 데이터를 사용할 수 있음


# 비동기처리

1. 작업이 시작된 후 즉시 결과를 기다리지 않고, 다른 작업을 계속할 수 있는 프로그래밍 방식임
2. 주로 네트워크 요청(API 호출), 파일 읽기, 타이머 등 시간이 오래 걸릴 수 있는 작업을 처리할 때 사용됨
3. 이 방식은 작업이 완료될 때까지 애플리케이션이 멈추지 않고, 다른 코드나 작업을 계속해서 실행할 수 있게 해줌
4. 동기처리(Synchronous)
```JS
	console.log('첫 번째 작업 시작');
	const result = performHeavyTask(); // 무거운 작업 실행 (예: API 호출)
	console.log('첫 번째 작업 완료:', result);
	console.log('다음 작업 진행');
```
- 한 번에 하나의 작업만 처리되며, 작업이 완료될 때까지 다음 작업을 진행할 수 없음
- 여기서 **performHeavyTask()**가 완료될 때까지 프로그램은 멈춰서 기다림
- 그다음 작업은 무거운 작업이 완료된 후에야 실행됨
5. 비동기처리(Asynchronous)
```JS
	console.log('첫 번째 작업 시작');
	setTimeout(() => {
	  console.log('첫 번째 작업 완료');
	}, 2000); // 2초 후에 실행
	console.log('다음 작업 진행');
```
- 작업이 완료되기를 기다리지 않고, 다른 작업을 동시에 진행할 수 있음
- 결과가 준비되면, 그 시점에 맞춰 특정 작업을 처리할 수 있도록 함
- 비동기 처리는 콜백 함수, Promise, async/await 같은 구조로 처리됨
- 위 코드에서 setTimeout은 비동기적으로 실행되며, 2초가 지나야 실행됨
- 그러나 **'다음 작업 진행'**은 즉시 실행됨
- 즉, 프로그램은 멈추지 않고, 타이머가 끝나는 동안 다른 작업을 처리함
6. 비동기 처리가 중요한 이유
    - 주로 시간이 오래 걸리는 작업(예: 네트워크 요청, 파일 읽기/쓰기, 타이머 등)을 처리할 때 유용
    - 만약 이런 작업을 동기 방식으로 처리한다면, 작업이 완료될 때까지 애플리케이션이 멈추게 되어 사용자 경험이 매우 나빠질 수 있음
    - 비동기 처리를 사용하면, 작업이 완료될 때까지 기다리는 동안에도 UI가 반응하고 다른 작업이 실행될 수 있음

## 비동기 처리의 주요 패턴
#### -> 비동기 처리 후 받은 데이터를 처리하는 방법

1. 콜백함수(Callback Function) -> 함수 안에 함수
    - 콜백 함수는 특정 작업이 완료된 후에 호출되는 함수임
    - 예를 들어, API 요청이 완료되었을 때 실행될 함수를 전달하여, 해당 작업이 끝난 후 처리하게 할 수 있음
2. Promise
    - Promise는 비동기 작업이 완료되었을 때 성공 또는 실패 결과를 반환하는 객체임
    - then과 catch를 통해 작업의 성공 또는 실패를 처리할 수 있임
3. async/await
    - Promise를 기반으로 한 비동기 처리 방식으로, 동기 처리처럼 보이지만 비동기 작업을 수행할 수 있게 해줌
    - await 키워드는 Promise가 해결될 때까지 기다림
4. async 함수
    - async 키워드는 함수 앞에 붙여서 그 함수가 비동기 함수임을 나타냄
    - 비동기 함수는 항상 Promise를 반환함
    - 함수 내부에서 return 값은 자동으로 resolve로 처리됨
5. await
    - await 키워드는 비동기 함수에서만 사용할 수 있으며, Promise가 처리될 때까지 함수 실행을 일시적으로 중지함
    - Promise가 resolve되면, 그 값을 반환받아 동기적으로 코드가 실행되는 것처럼 이어짐
    - async 함수 내부에서 await를 사용하여 비동기 작업이 완료될 때까지 기다림
    - await는 해당 비동기 작업이 완료될 때까지 코드 실행을 일시 중지하고, 완료되면 다시 실행함

## 비동기 처리의 장점

1. UI 반응성 유지 : 무거운 작업을 수행할 때도 애플리케이션이 멈추지 않고 계속해서 동작함
2. 성능 최적화 : 네트워크 요청, 파일 읽기 등 시간이 오래 걸리는 작업이 완료될 때까지 기다리지 않고, 다른 작업을 동시에 수행할 수 있음
3. 사용자 경험 향상 : 데이터를 처리하거나 로딩하는 동안도 애플리케이션이 반응하며, 사용자에게 즉각적인 피드백을 제공할 수 있음

# Redux

1. 상태 관리 라이브러리로, 애플리케이션의 전역 상태를 관리하는데 도움을 줌
2. 복잡한 리액트 애플리케이션에서는 여러 컴포넌트 간의 상태 공유가 어렵기 때문에, Redux를 사용하여 중앙 집중화된 스토어를 통해 상태를 효율적으로 관리할 수 있음
3. Redux는 주로 리액트와 함께 사용되지만, 다른 라이브러리나 프레임워크와도 함께 사용할 수 있음
4. Redux의 핵심 개념 : 스토어와 액션은 둘 다 객체임
    - 스토어(Store)
1. 애플리케이션의 전역 상태를 저장하는 곳
2. createStore 함수를 사용하여 스토어를 생성하고, 이 스토어는 애플리케이션 전반에서 상태를 유지하고 관리하는 역할을 함
    - 액션(Action)
1. 상태를 변경하기 위해 발생시키는 이벤트를 의미함
2. 액션은 객체 형태로 { type: 'ACTION_TYPE', payload: 데이터 }의 구조를 가짐
<br>->type 필드는 액션의 종류를 나타냄. payload는 해당 액션과 함께 전달할 추가 데이터를 나타냄

## 리듀서(Reducer) : 상태를 변경하는 순수 함수

1. 순수함수
    - 주어진 입력만을 사용하여 결과를 도출하고, 함수 외부의 상태나 변수에 의존하지 않으며, 부작용(side effect)을 일으키지 않는 함수임
    - 동일한 입력값에 대해 항상 동일한 결과를 반환한다는 특징이 있어, 이를 통해 예측 가능한 동작과 함수의 테스트 용이성을 제공함
2. 순수 함수의 주요 특징(아래4가지)
3. 동일한 입력에 대한 동일한 출력(입력 값이 같으면 항상 동일한 결과를 반환함)
4. 외부 상태에 의존하지 않음 : 함수는 함수 내부의 로컬 변수와 입력 값만 사용하며, 외부의 변수나 상태를 변경하거나 의존하지 않음
5. 부작용이 없음 : 함수가 외부의 상태나 변수에 영향을 주지 않으며, 입력 값만 처리하고 반환함
```JS
    let count = 0;

	function increaseCount() {
  	count++; 
	}
```
- 전역 상태를 변경하는 부작용이 발생함 -> 순수 함수가 아님
6. 디스패치(Dispatch)
    - 액션을 스토어에 전달하는 메서드임
    - 컴포넌트에서 디스패치를 통해 액션을 발생시키고, 리듀서가 상태를 업데이트하도록 함
7. Redux의 필요성 : Redux를 사용하면 상태를 중앙에서 관리하여 컴포넌트 간의 의존성을 줄이고, 
상태 관리가 보다 예측 가능하고 유지보수하기 쉬워짐
8. Redux 동작 원리
    - 스토어 생성: 애플리케이션의 상태를 보관할 스토어를 생성
    - 액션 디스패치: 사용자 인터랙션이나 기타 이벤트에 따라 액션을 디스패치
    - 리듀서 호출: 디스패치된 액션을 리듀서가 받아 새로운 상태를 계산함
    - 상태 업데이트: 스토어의 상태가 업데이트되고, 이를 구독(mount)하고 있는 컴포넌트들이 리렌더링됨

### Context API vs Redux

1. Redux를 선택할 때
    - 애플리케이션의 상태 관리가 복잡하거나 규모가 큰 경우
    - 상태 변경 로직을 명확하게 분리하고 싶을 때
    - 강력한 디버깅 도구와 미들웨어를 활용하고 싶을 때
2. Context API를 선택할 때
    - 상태 관리가 비교적 간단하고 작은 규모의 프로젝트일 때
    - 추가적인 라이브러리 설치 없이 빠르게 전역 상태를 관리하고 싶을 때
    - 성능 최적화가 크게 필요하지 않은 경우
3. Redux 설치 : npm install redux react-redux
    - react-redux 패키지 : React 애플리케이션에서 Redux를 쉽게 사용할 수 있도록 돕는 바인딩 라이브러리
    - 바인딩 라이브러리
    - 두 개 이상의 시스템이나 라이브러리 간의 연결을 원활하게 해주는 역할을 하는 소프트웨어임
    - 서로 다른 기술이나 API를 사용하는 시스템이 함께 동작하도록 돕는 것
4. Redux 사용
    - Provider 컴포넌트
    - 애플리케이션 전체에 스토어를 제공함
    - 최상위 컴포넌트를 감싸서 모든 자식 컴포넌트가 Redux 스토어에 접근할 수 있게 해줌
    - userSelector
    - Redux 스토어에서 상태를 선택하고 React 컴포넌트에서 사용할 수 있게 함(context에서 consumer에 해당함)
    - useSelector를 사용하면 스토어의 특정 상태를 선택해서 가져올 수 있음
    - useDispatch : 액션을 디스패치하는 함수로, 컴포넌트에서 액션을 발생시켜 상태를 변경할 수 있게 함

#### Redux 실습_action.js

1. 액션(Action): 상태를 변경하는 이벤트
2. 'INCREMENT'라는 타입의 액션을 반환하는 함수 : 이 액션은 리듀서에서 상태를 증가시키기 위한 신호로 사용됨
3. 'DECREMENT'라는 타입의 액션을 반환하는 함수 : 이 액션은 리듀서에서 상태를 감소시키기 위한 신호로 사용됨
4. increment와 decrement 함수는 각각 액션 객체를 반환하는 함수임
5. 이 함수들은 단순히 특정 **타입(type)**을 가진 객체를 반환하는데, 이 객체는 Redux 리듀서에서 상태를 변경하기 위한 신호로 사용됨
6. type은 Redux 리듀서가 상태를 어떻게 변경할지 결정하는 기준이 됨
7. 액션은 상태 변경을 트리거하기 위한 이벤트로, increment는 상태를 증가시키고 decrement는 상태를 감소시키는 역할을 한다는 점에서 중요한 이벤트로 사용

#### Redux 실습_reducer.js

1. 리듀서(Reducer): 액션에 따라 상태를 변경하는 순수 함수 -> 거의 직접 만듦
2. 리듀서의 기본 구조
    - 현재 상태(state) : 리듀서가 관리하는 현재 상태로, 리듀서가 처음 호출될 때 초기 상태가 설정됨
    - 액션(action) : 상태를 변경할 이벤트. 액션 객체는 최소한 type 속성을 가지며, 상태를 어떻게 변경할지 리듀서에게 알려줌
3. 리듀서의 역할
    - 액션의 타입에 따라 상태를 변경하고, 새로운 상태 객체를 반환함
    - 중요한 점은 상태를 직접 변경하는 것이 아니라, 새로운 상태 객체를 반환함으로써 **불변성(immutability)**을 유지한다는 것임
    - 리서는. 액션에 의해 트리거(호출)되며, 주어진 상태와 액션을 바탕으로 새로운 상태를 계산함
4. ...state의 의미 : 스프레드 연산자는 객체의 모든 속성을 얕게 복사하는 역할
5. 상태 불변성 유지 : 
    - Redux에서는 상태를 직접 변경하는 대신, 불변성을 유지하면서 새로운 상태 객체를 반환하는 것이 중요함
    - 직접 상태를 변경하지 않고 새로운 객체를 반환함으로써, 과거 상태를 유지하고, 변경 사항을 추적할 수 있음

#### Redux 실습_store.js & App.js

1. 스토어(Store): 애플리케이션의 상태를 저장하는 객체
2. 증가 혹은 감소 버튼을 누르면 dispatch(액션함수)가 실행이 되고, 액션함수를 통해 반환받은 객체를 리듀서 함수로 보냄
3. 리듀서에서 상태를 업데이트하면 재렌더링이 되고, 화면에 바뀐 값이 출력이 됨
4. Increment 버튼을 클릭하면 dispatch(increment())가 호출됨
<br>->increment()는 { type: 'INCREMENT' } -> dispatc({ type: 'INCREMENT' })를 counterReducer의 인자를 전달함


## 비동기 처리방식 :  Fetch API와 Axios

1. 둘 다 Promise 기반임
2. Fetch API
    - 브라우저에서 제공하는 비동기 네트워크 요청을 수행하는 기본 API임
    - Promise를 반환하며, 네트워크 요청의 성공 여부에 따라 성공 또는 실패 상태로 처리됨
    - 데이터받아서 json으로 변환해줘야 함
3. Axios
    - Promise 기반 HTTP 클라이언트로, Fetch API보다 기능이 더 풍부하고 편리함
    - 자동으로 JSON 변환을 수행하고, 에러 처리가 더 간편하게 구현됨
    - 사용 전에 설치해야함 -> npm install axios
4. 전송방식 : GET, POST, PUT, DELET
5. JSONPlaceholder
    - 테스트 및 프로토타입을 위한 샘플 데이터를 제공하는 무료 온라인 REST API서비스임
    - 게시글, 댓글, 앨법, 사진 등 실제 백엔드를 설정하지 않고도 애플리케이션을 테스트하는 데 사용할 수 있는 Fake 데이터를 제공함
    - 실제 데이터를 생성하거나 라이브 API에 의존할 필요 없이 응용 프로그램의 기능을 스트. 고자 하는 사람에게 매우 유용한 서비스임
    - https://jsonplaceholder.typicode.com/guide/

### Fetch 실습

1. HTTP(Hype Text Transfer Protocol)
    - HTML문서와 같은 리소스를 가져올 수 있도록 해주는 규약(Protocol)임
    - 웹에서 이루어지는 모든 데이터 교환의 기초
    - 클라이언트-서버 프로토콜이라고 하기도 함
2. HTTP상태코드
    - 브라우저는 서버에 보내주는 상태코드를 보고 request가 성공했는지 실패했는지의 여부를 판단함
    - 2xx : 성공을 알리는 상태코드 ex. 200
    - 3xx : 리다이렉션(다른페이지)을(를) 알리는 상태코드
    - 4xx : 요청오류를 나타냄 -> 요청 자체에 오류가 있음
	<br>ex. 400(잘못된 요청) | 401(권한없음) | 403(금지됨) | 404(찾을 수 없음)
    - 5xx : 서버오류를 나타냄 -> 요청은 제대로 왔지만 서버에 오류가 생겼을 때 발생함
    <br>ex. 500(내부 서버 오류)
3. HTTP 요청 메서드
    - 클라이언트가 서버에 데이터를 전송하여 응답을 얻고자 할 때 사용하는 방식
    - GET : 서버 자원을 가져오고자 할 때 사용한다. 요청의 본문에 데이터를 넣지 않음 -> 데이터를 서버로 보내야 한다면 쿼리스트링을 사용함
    - POST : 서버에 자원을 새로 등록하고자 할 때 사용함 -> 요청의 본문에 새로 등록할 데이터를 넣어 보냄
    - PUT : 서버의 자원을 요청에 들어 있는 자원으로 치환하고자 할 때 사용함 -> 요청의 본문에 치환할 데이터를 넣어 보냄
    - DELET : 서버 자원을 삭제하고자 할 때 사용함 -> 요청의 본문에 데이터를 넣지않음
    - OPTIONS : 요청을 하기 전에 통신 옵션을 설명하기 위해 사용함
