# React

1. 자바스크립트 라이브러리
2. node.js가 있어야 npm(Node Package Manager)을 이용해서 설치가 가능함

## App.js

1. JSX문법 : 자바스크립트 안에 HTML코드가 들어가는 것
    - 컴포넌트 : 리액트로 만들어진 앱을 이루는 최소한의 단위, 페이지에 렌더링 할 React엘리먼트를 반환하는 작고 재사용 가능한 코드조각임
	- 형식 : <컴포 /> 
        1. App.js에 HTML JSX export 
        2. index.js에 import해서 <App \/>하기
2. export default App;
    - 해당파일에서는 하나의 컴포넌트만을 내보냄
    - export default구문을 사용해 내보낸 컴포넌트는 중괄호를 사용하지 않고 불러올 수 있으며, 이름 또한 원하는 이름으로 바꿔서 불러올 수 있음

## Props와 Hook

1. Props : 부모 컴포넌트가 자식 컴포넌트에게 전달하는 값, props는 객체이고 뭔가를 넘겨받을 때 자식컴포넌트에서는 'props.이름' 으로 접근할 수 있음(단방향, 자식은 렌더링만 가능)
2. Hook
    - 리액트 16.8에 새로 도입된 기능
    - import React,{useState} from "react" 중 useState : 
    - 리액트에서 사용되는 Hook중 하나로 함수형 컴포넌트에서 상태 변수를 사용할 수 있게 해줌
    - 훅을 사용하면 리액트가 제공하는 기능과 상태변수를 사용할 수 있음
### useState
1.  상태를 관리하는 Hook의 일종
2. 함수형 컴포넌트에서 상태 변수와 이를 업데이트할 수 있는 함수를 반환
3. 형식 : const[state, setState] = useState(값의타입);
 
|state|현재 상태 값을 나타내는 변수|
|---|---|
|setState|상태를 업데이트하는 함수|
|initialState|상태의 초기값. 기본값을 설정하며, 숫자, 문자열, 배열, 객체 등 다양한 데이터 타입을 사용할 수 있음|

4. 배열구조분해
    - const [count, setCount] = useState(0);을 풀어쓰면 아래와 같음
    ```JS
    let countArray = useState(0);
    let count=countArray[0];
    let setCount=countArray[1];
    ```

### useEffect hook
1. React의 함수형 컴포넌트에서 사이드 이펙트를 처리하는 데 사용됨
2. 사이드 이펙트는 컴포넌트의 렌더링과는 직접적으로 관련이 없는 작업들을 말함
3. 예를 들어 데이터 fetching, 구독 설정, 타이머 설정 등이 있음
4. useEffect 훅은 컴포넌트가 렌더링된 후에 특정 작업을 수행하거나 컴포넌트가 업데이트되었을 때 실행되는 코드를 작성할 수 있게 해줌
5. 사용법 예시
    ```JS
    import React, { useEffect, useState } from 'react';

    function MyComponent() {
    const [count, setCount] = useState(0);

    useEffect(() => {
        //이 부분이 사이드 이펙트 코드
        document.title = `You clicked ${count} times`;

        //클린업 함수 (선택적) -> 없어도 됨
        return ( ) => {
        //컴포넌트가 언마운트되거나 의존성 배열의 값이 변경되기 전에 실행
        //값이 들어옴 -> 마운트, 값이 나감 ->언마운트
        <div id = 'root'>
        </div>
        };
    }, [count]); // 의존성 배열

    return (
        <div>
            <p>You clicked {count} times</p>
            <button onClick={() => setCount(count + 1)}>Click me</button>
        </div>
    );
    }
    ```
6. useEffect 주요개념
    - 첫 번째 인자 : 사이드 이펙트 함수
        1. useEffect의 첫 번째 인자는 사이드 이펙트 로직을 포함한 함수임
        2. React의 함수형 컴포넌트에서 사이드 이펙트를 처리하는 데 사용됨
        <br>-> 사이드 이펙트는 컴포넌트의 렌더링과는 직접적으로 관련이 없는 작업들을 말함(예를 들어 데이터 fetching, 구독 설정, 타이머 설정 등이 있음)
        3. 이 함수는 컴포넌트가 렌더링된 후에 실행됨
    - 두 번째 인자: 의존성 배열
        1. 이 배열에 포함된 값들이 변경될 때만 사이드 이펙트 함수가 다시 실행됨
        2. 배열을 생략하면 사이드 이펙트 함수는 매 렌더링마다 실행됨
        3. 배열이 빈 경우, 사이드 이펙트 함수는 컴포넌트가 처음 마운트될 때만 실행됨

        |의존성 배열이 비어 있는 경우 ( [ ] )|-이 경우, useEffect는 컴포넌트가 처음 마운트될 때만 실행<br>-이후에는 사이드 이펙트가 다시 실행되지 않음|
        |---|---|
        |의존성 배열에 상태나 프로퍼티를 포함하는 경우|-이 경우, 의존성 배열에 포함된 값들이 변경될 때마다 useEffect의 사이드 이펙트 함수가 실행됨<br>-0을 count에 적용함|
        |의존성 배열이 없는 경우|-사이드 이펙트 함수는 컴포넌트가 렌더링될 때마다 실행됨<br>-이는 의존성 배열을 생략한 경우의 기본 동작임|

    - 클린업 함수 (선택적)
        1. 사이드 이펙트 함수는 선택적으로 클린업 함수를 반환할 수 있음
        2. 이 클린업 함수는 컴포넌트가 언마운트되거나 의존성 배열의 값이 변경되기 전에 실행됨
        3. 예를 들어, 타이머를 설정한 경우 클린업 함수에서 타이머를 정리할 수 있음
    - 데이터 fetching : 컴포넌트가 마운트될 때 데이터를 가져오고, 컴포넌트가 언마운트될 때 요청을 취소하거나 클린업 작업을 수행할 수 있음

### useRef hook

1. React에서 DOM 요소나 컴포넌트 인스턴스에 대한 레퍼런스(값)를(을) 유지할 때 사용됨
2. useState와 달리 렌더링 사이에서 값을 저장할 수 있으며, 컴포넌트가 다시 렌더링되더라도 값이 유지됨
3. 컴포넌트 렌더링과 관련이 없는 값을 저장하거나, DOM 요소(HTML태그)에 직접 접근할 때 유용함
4. 생성 형식 : const 변수명 = useRef(초기값)
<br>->함수의 실행 결과로 {current : 초기값}을 지닌 객체가 반환됨
<br>->사용할 때는 변수명.current 로 쓸 수 있음

5. useState가 지역변수라면 useRef는 전역변수라고 볼 수 있음
6. 주요 기능
    - DOM 요소(HTML태그)에 접근하기
        1. 컴포넌트가 렌더링된 후 DOM 요소에 접근할 수 있음
        2. 이 기능은 폼 요소에 포커스를 설정하거나, 스크롤 위치를 조정하는 등의 작업에 유용함
        3. 바닐라 자바스크립트의 getElementById(무조건 id를 사용해서 접근), querySelector와 비슷함
    - 렌더링 한 값 유지하기
        1. 렌더링 간에 값을 저장할 수 있음
        2. 이 값은 컴포넌트의 렌더링 사이에서 변경될 수 있지만, 상태 업데이트로 인해 렌더링을 트리거하지 않음
        3. 구독 객체나 타이머 ID를 저장하고, 클린업 함수에서 이러한 값을 활용할 수 있음
7. 자주바뀌는 값을 state에 넣으면 바뀔때마다 렌더링이 일어나서 성능일 떨어질 수 있음
<br>but.이 때 useRef를 사용하면 값이 바뀌어도 렌더링이 발생하지 않아 성능저하를 막을 수 있음

### 추가적인 개념설명

1. map( )
    - 반복문 안에 들어있는 내용을 하나씩 꺼내서 처리함
    - 예시1:
    ```JS
    [1,2,3].map(function(a){
	console.log(1)});//을 출력하면 1이 3번 출력됨
    ```
    - 예시2 : 
    ```JS
    [1,2,3].map(function(a){
	console.log(a)});//을 출력하면 1,2,3이 출력됨
    ```
2. key
    - 요소의 리스트를 만들 때, React에서 컴포넌트를 렌더링했을 때 어떤 아이템이 변경되었는지 빠르게 감지하기 위해 사용함
    - 만약 key가 설정되지않았다면 가상DOM을 순차적으로 비교하면서 감지하기때문에 KEY가 없을때보다 속도가 느림
3. ...
    - 스프레드 연산자로 배열이나 객체의 요소를 개별적으로 펼쳐서 다른 배열이나 객체에 삽입할 때 사용됨
    - 리액트에서 상태를 업데이트할 때 사용함
4. material-ui를 이용한 디자인
    - material-ui는 다양한 컴포넌트를 제공함
    - ListItem, ListItemText, InputBase, CheckBox 등의 컴포넌트를 이용해 복잡한 CSS를 사용하지 않고도 UI를 개선할 수 있음

### 리액트 컴포넌트 생명주기

1. 리액트 컴포넌트는 생성, 업데이트, 제거라는 세 가지 주요 단계에서 작동하며, 각 단계에서 특정한 메서드들이 실행됨
2. 생명주기 메서드를 통해 컴포넌트가 언제 생성되었고, 언제 상태나 props가 변경되었으며, 언제 제거될지 제어할 수 있음
3. 컴포넌트 생명주기는 클래스형 컴포넌트에서 주로 사용되었으며, 함수형 컴포넌트에서는 useEffect 훅을 사용해 비슷한 동작을 구현할 수 있음
4. 컴포넌트 생명주기 메서드 : 생성, 업데이트, 제거
5. 생성(Mount)
    - constructor( ) : 컴포넌트가 생성될 때 가장 먼저 호출되며, 초기 상태(state)를 설정할 수 있음
    - render( ) : UI를 렌더링하는 메서드로, JSX를 반환함
    - componentDidMount( )
    <br>->컴포넌트가 처음 렌더링된 후 호출됨
    <br>->주로 API 호출 등 초기 데이터를 가져오는 작업을 수행함
6. 업데이트(Updating) : 컴포넌트가 업데이트될 때, 즉 props나 state가 변경될 때 호출되는 메서드들임
    - shouldComponentUpdate( ) :
        1. 컴포넌트가 업데이트될지 여부를 결정함
        2. 성능 최적화를 위해 사용됨
        3. true를 반환하면 업데이트가 진행되고, false를 반환하면 업데이트가 중단됨
    - componentDidUpdate( ) : 
        1. 컴포넌트가 업데이트된 후 호출됨
        2. 업데이트 직후에 추가 작업을 수행할 때 사용됨
7. 제거(Unmounting) : 컴포넌트가 DOM에서 제거될 때 호출되는 메서드임
