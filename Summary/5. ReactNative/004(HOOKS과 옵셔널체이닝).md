# Hooks

1. 이전에는 컴포넌트의 상태를 관리하거나 생명 주기에 따라 특정 작업을 수행하려면 클래스형 컴포넌트를 사용해야 했음
2. 하지만 Hooks를 이용할 수 있게 되면서 함수형 컴포넌트에서도 상태를 관리할 수 있게 되었고 컴포넌트의 생명 주기에 맞춰 특정 작업을 수행할 수 있게 되었음

## useState

1. useState 함수를 호출하면 파라미터로 전달한 값을 초기값으로 갖는 상태 변수와 그 변수를 수정할 수 있는 세터함수 배열로 반환함함
2. useState 함수는 관리해야 하는 상태의 수만큼 여러 번 사용할 수 있음
3. 상태를 관리하는 반드시 세터 함수를 이용해 값을 변경해야 하고, 상태가 변경되면 컴포넌트가 변경된 내용을 반영하여 다시 렌더링 됨
4. 예시
```JS
const[state, setState] = useState(initialState);
```

### useState를 사용하는 이유

1. useState로 만든 상태는 컴포넌트가 리렌더링되더라도 값이 유지됨
2. 상태가 업데이트되면 리액트가 이를 감지해 자동으로 컴포넌트를 다시 렌더링하여 최신 상태가 화면에 반영됨 -> 즉, 상태 값의 변화를 반영하려면 useState가 필요함
3. 리액트 컴포넌트는 props를 통해 다른 컴포넌트와 데이터를 주고받음
4. useState로 관리하는 값은 props로 하위 컴포넌트에 전달할 수 있어 부모와 자식 컴포넌트 간에 상태를 공유하거나 데이터를 전달할 수 있게 됨
5. 변수를 통해 만든 값은 상태가 아니기 때문에 다른 컴포넌트에 props로 전달해도 리렌더링에 따라 값이 초기화될 수 있어 예기치 않은 동작을 초래할 수 있음
6. 리액트가 상태를 추적하는 원리는 **불변성(immutability)과 참조 비교(reference comparison)**를 활용하는 것에 기반을 두고 있음
    1. 불변성(Immutability)을 통한 상태 관리
        - 리액트는 상태가 불변하다고 가정하고, 상태 변경 시 항상 새로운 상태 객체를 생성함
        - 이 불변성 덕분에 리액트는 참조만으로 상태가 변했는지 쉽게 감지할 수 있음음
        - 상태를 직접 변경하지 않고 새로운 객체를 만들어야 리액트가 이를 "변경된 상태"로 인식함
        - 만약 기존 상태를 직접 변경하면 기존 참조와 새로운 참조가 동일해 리액트가 이를 변경으로 감지하지 못함
    2. 불변성을 지키지 않고 객체를 수정할 수는 있으나, 리액트에서 이런 식으로 상태를 변경하면 문제가 발생할 수 있음
    3. 불변성을 유지하는 경우 리액트는 상태가 변경되었다고 인식해 컴포넌트를 다시 렌더링하게 됨

## useEffect

1. 컴포넌트가 렌더링 될 때마다 원하는 작업이 실행되도록 설정할 수 있는 기능임
2. 예시
```JS
useEffect(() => {}, []);
```
3. 첫번째 파라미터로 전달된 함수는 조건을 만족할 때마다 호출되며, 두번째 파라미터로 전달되는 배열을 이용해 함수가 호출되는 조건을 설정할 수 있음
4. useEffect의 두 번째 파라미터에 빈 배열을 전달하면 컴포넌트가 처음 렌더링 될 때만 함수가 호출되도록 작성할 수 있음
5. 클린업 함수
    - 클린업(clean-up) 함수는 컴포넌트가 언마운트되거나, useEffect가 다시 실행되기 전에 실행되는 함수
    - 주로 리소스를 정리하거나, 이벤트 리스너를 제거하거나, 타이머를 정리하는 등 필요한 뒷처리를 수행하기 위해 사용함

## useRef

1. 특정 DOM 요소나 값의 변화를 추적하거나 유지할 때 사용되는 객체를 반환해 주는 역할을 함
2. DOM 요소에 접근하기 위해 사용하거나, 리렌더링 없이 상태를 유지할 때 사용하는 경우임
3. 주요 특징
    - 초기 값 유지: useRef의 초기 값은 컴포넌트가 마운트될 때 한 번만 설정되며 이후에는 유지됨
    - 리렌더링 없이 값 유지: useRef의 값이 바뀌어도 컴포넌트는 리렌더링되지 않으므로, 값의 변경이 UI에 즉각적인 영향을 주지 않아야 할 때 유용함
    - DOM 접근: useRef는 컴포넌트의 특정 DOM 요소에 접근할 때 사용할 수 있음
    <br>-> 주로 input, button 등 특정 DOM 요소에 직접 접근해 포커스를 설정하거나, 요소의 값을 직접 조작할 때 사용됨

## useMemo

1. useMemo는 React에서 제공하는 훅으로, 메모이제이션을 활용해 특정 연산의 결과를 저장해두고, 불필요한 반복 계산을 피하도록 도와줌
2. 이 훅은 복잡한 계산이 매번 다시 이루어지지 않도록 최적화하는 역할을 하며, 의존성 배열에 따라 값이 바뀔 때만 연산이 다시 수행되도록 설정할 수 있음

### 메모제이션와 useMemo

1. 메모이제이션이란 같은 계산을 반복해야 할 때 그 결과를 저장해두고, 다시 필요할 때 저장된 값을 꺼내 사용하는 기법임
2. 반복적으로 동일한 연산을 수행하지 않아도 되어, 성능이 크게 향상됨
3. useMemo는 이 메모이제이션을 React 컴포넌트에서 사용할 수 있도록 지원하는 훅임
4. useMemo의 동작 방식
    - useMemo는 특정 계산의 결과를 기억하고 있다가, 다음에 해당 계산이 필요할 때 의존하는 값이 바뀌지 않았으면 이전 결과를 그대로 반환함
    - 만약 의존하는 값이 바뀌었다면, 새로운 결과를 계산해 반환하고, 그 결과를 다시 기억함
    ```JS
    useMemo(()=>{},[]);
    ```
    - 첫 번째 파라미터에는 함수를 전달하고, 두 번째 파라미터에는 함수 실행 조건을 배열로 전달하면 지정된 값에 변화가 있는 경우에만 함수가 호출됨
5. 복잡한 배열 연산이나 필터링, 정렬 등의 작업을 useMemo로 최적화할 수 있음

# 옵셔널 체이닝

1. JavaScript에서 객체의 속성에 안전하게 접근하기 위한 문법이 있음
2. 이 문법을 사용하면, 중첩된 객체 속성에 접근할 때 객체나 속성이 존재하지 않아도 에러를 발생시키지 않고 undefined를 반환하도록 함
3. 옵셔널 체이닝을 통해 코드가 중단되지 않고 안전하게 실행될 수 있음
4. 옵셔널 체이닝 문법 :  옵셔널 체이닝은 ?.를 사용하여 작성함
5. 옵셔널 체이닝을 사용하면 배열이 존재하지 않거나, 해당 인덱스의 요소가 없어도 안전하게 접근할 수 있음
6. 옵셔널 체이닝의 장점
    - 안정성 : null 또는 undefined인 값에 접근할 때 발생하는 오류를 방지함
    - 가독성 : 여러 중첩된 속성에 접근할 때 코드를 짧고 명확하게 작성할 수 있음
    - 간편한 에러 처리 : 값이 없을 경우 undefined를 반환하기 때문에 별도의 if문이나 try-catch문 없이도 에러 처리가 가능함
