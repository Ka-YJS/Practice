# 추상화

## 추상화란?

1. 공통성과 본질을 모아 추출하는것
2. 기존 클래스들의 공통적인 요소를 모아 상위 클래스를 만들어내는 기술
3. 공통적인 속성과 행위를 모아 정의하면, 반복적인 코드를 줄일수 있고, 보다 효과적인 클래스간의 관계를 설정하여 유지보수가 용이해짐

## 추상메서드

1. 선언부만 작성하고 구현부는 작성하지 않고 남겨둔 미완성 메서드를 '추상 메서드'라고 함
2. 다형성을 위해 메서드의 선언은 통일해야 하지만, 실제로 구현하는 내용은 자식클래스마다 달라야 할 때 사용됨
3. 부모 클래스의 메서드는 비워두고 자식 클래스에서 오버라이딩하여 구현을 할 수 있음
4. 추상 메서드를 선언할 때 abstract 키워드를 함께 표기해야 함
5. 또한 메서드의 구현부인 중괄호{} 대신 구현부가 없다는 의미로 세미콜론(;)를 사용함
6. 형식
```java
	[접근제한자] abstract [반환형] [메서드명](파라미터1,파라미터2);
	abstract [접근제한] [반환형] [메서드명](파라미터1,파라미터2);
    //파라미터=매개변수, { } 없음
```

## 추상클래스

1. 추상메서드가 한 개 이상 정의되어 있는 클래스를 추상 클래스라고 함
2. 추상 메서드를 포함하고 있다는 것을 제외하고 일반 클래스와 다르지 않음
3. 추상 클래스에도 생성자가 있으며, 멤버변수와 메서드도 가질 수 있음
4. 추상 클래스 또한 abstract를 통해 자신이 추상클래스임을 명시해줘야 함
5. 형식
```java
[접근제한자] abstract class [클래스명]{
	필드
	생성자
	메서드(추상메서드 포함) //abstract를 사용할때 메서드는 추상메서드로 표기해야 함
}
```
6. 특징
	- 일반 클래스 처럼 독립적으로 생성자를 호출해 객체를 생성할 수 없음
	- 자식 클래스의 생성자에 super()를 통해 추상 클래스의 생성자를 호출하여 부모 객체를 생성한 후 자식 객체를 생성함
	- 추상클래스는 사실 일반 클래스와 크게 다를것은 없어보이지만, 직접 객체를 생성하지 못한다는 사실을 알 수 있음

### 추상클래스에 추상메서드의 구현

1. 자식 클래스들이 반드시 구현해야 하는 메서드가 있다면, 우리는 추상 메서드로 해당 메서드를 부모 클래스(추상클래스)에 선언해 둘 수 있음
2. 추상 클래스를 상속받은 모든 자식 클래스는 반드시 추상 메서드를 오버라이딩 및 재정의하여 구현해야 함(그렇지않으면 컴파일 에러 발생)

### 추상 클래스와 추상 메서드의 용도

1. 자식 클래스 간의 공통적인 필드와 메서드 이름을 통일할 수 있음
2. 반드시 구현해야 하는 메서드를 선언함으로써 공통 규격을 제공함

# 인터페이스

## 인터페이스란?

1. 모든 메서드가 추상 메서드인 일종의 추상 클래스를 '인터페이스'라고 부름
2. 인터페이스는 추상 메서드와 상수 로만 이루어져 있으며, 추상클래스와 마찬가지로 스스로 객체를 생성할 수 없음
3. 언뜻 보면 인터페이스와 추상 클래스가 같은 역할을 하는 것처럼 느껴질 수 있지만, 취지는 완전히 다름
4. 추상 클래스는 자식클래스들의 공통적인 특징을 추출하고 제공하는것이 주된 역할이었다면 인터페이스는 그뿐 아니라 다른 클래스 코드들과의 중간 매개 역할을 하는 것을 중점으로 생각할 수 있음

### 인터페이스의 선언

1. 인터페이스는 클래스가 아님
2. 추상클래스는 스스로 객체를 생성할 수는 없지만, 자식 클래스의 생성자를 통해 객체를 생성해낼 수 있음
3. 하지만 인터페이스는 어떤 형태로도 객체를 만들 수 없기 때문에 클래스라고 부를 수 없음
4. 인터페이스는 객체의 매개체, 즉, 객체를 사용하는 방법을 제공하는 새로운 블록이라고 할 수 있음
5. 형식
```java
[접근제한자]interface 인터페이스명{
	상수
	추상메서드
}
```
6. 인터페이스를 선언하는 방법은 클래스를 작성하는 방법과 동일하며 class키워드 대신 interface를 작성함
7. 또한, 인터페이스의 추상 메서드는 다른 클래스들과의 매개체 역할을 하므로 누구나 접근할 수 있음
8. 따라서 항상 public으로 구현함
9. 만약 접근자를 default로 구현했다면 자동으로 public으로 인식함

### 상수의 선언

1. 인터페이스에서는 필드 대신 상수를 선언할 수 있음
2. 단, 상수이기 때문에 인터페이스는 고정된 값만 선언할 수 있어 충분한 고민을 통해 선언해야 함
3. 형식
```java
[접근제한자] interface 인터페이스 이름{
	public static final 자료형 상수명 = 값;
}
```
- public : 인터페이스는 다른 클래스들의 접근이 가능해야 하기 때문에 public으로 함
- static : 객체가 생성되지 않는 인터페이스이기 때문에, 내부 상수에 접근하려면 클래스 변수처럼 static으로 선언되어 메모리에 올라가있어야 함
- final : 상수를 뜻하는 키워드임

### 인터페이스 사용

1. 추상 클래스는 추상 메서드가 비어있기 때문에 객체 생성을 스스로 할 수 없음 -> 대신 자식 클래스의 생성자의 힘을 빌려 객체 생성을 할 수 있었음
2. 인터페이스도 마찬가지로 추상 메서드가 비어있기 때문에 객체 생성을 스스로 할 수 없음
3. 따라서 인터페이스도 자신이 가지고 있는 추상 메서드를 구현해줄 클래스를 작성해야만 함
4. 인터페이스를 구현해주는 클래스를 '구현 클래스'라고 함

### implements

1. 구현 클래스는 인터페이스를 사용해 구현하겠다는 선언을 해야 함
2. 구현한다는 의미를 가지고 있는 implements키워드를 사용하여 명시할 수 있음
3. 형식
```java
[접근제한자]class 클래스명 implements 인터페이스명{
	필드
	생성자
	메서드(추상메서드 오버라이딩)
}
```

### 인터페이스의 장점

1. 정보은닉 : 실제 구현 클래스의 내용을 전혀 보지 않고도 개발 코드로 객체를 사용할 수 있음
2. 모듈화
	- 구현 클래스들이 독립적으로 구현되고 사용될 수 있음
	- 개발 코드에서 객체 변경이 필요할 때, 개발코드의 수정을 최소화할 수 있음

### 다중 인터페이스 구현
1. 우리는 하나의 클래스로 여러 개의 인터페이스를 구현할 수 있음
2. 선언한 모든 인터페이스에 대한 추상 메서드를 모두 구현해 줘야 함
3. 형식1
```java
[접근제한자]class 클래스명 implements 인터페이스1,인터페이스2{
	필드
	생성자
	인터페이스1에 대한 구현 메서드
	인터페이스2에 대한 구현 메서드
}
```
4. 형식2
```java
class 클래스명 implements 인터페이스1, 인터페이스2{
	필드, 메서드, 생성자, 추상메서드의 구현체}
```

### 인터페이스 상속
1. 인터페이스끼리 상속관계를 만들 수 있음
2. 클래스의 상속과 만찬가지로 extends키워드를 사용하며, 다중 상속이 가능하기 때문에 콤마(,)를 이용해서 다음과 같이 선언함
3. 형식
```java
[접근제한자] interface 인터페이스명 extends 인터페이스1, 인터페이스2,...{ 
}
```
- 인터페이스명 : 자식, 하위, 파생
- 인터페이스 : 부모, 상위, 기반
4. 인터페이스 상속을 선언하면, 하위 클래스는 상위 클래스의 모든 멤버를 상속받게 됨
5. 만약 하위 인터페이스를 구현하는 클래스가 있다면, 해당 클래스는 하위 인터페이스의 추상메서드를 포함하여 상위 인터페이스들의 추상 메서드까지 구현해야 함

# 추상 클래스와 인터페이스의 공통점

1. 정보은닉, 모듈화, 추상화 등은 추상클래스와 인터페이스가 공통적으로 가진 장점임
2. 추상 클래스와 인터페이스 모두 다형성을 구현할 수 있는 기반을 제공하며, 추상 메서드 구현에 대한 강제성을 반영하고 있음