# 제네릭(Generic)

1. JDK 1.5 이전에는 여러 타입을 사용하는 대부분의 클래스나 메서드에서 반환값으로 Object타입을 사용했음
2. 이러한 경우 잘못된 캐스팅으로 인해 런타임 오류가 발생할 가능성이 있음
3. JDK 1.5부터 도입된 제네릭을 사용하면 컴파일할 때 타입이 미리 정해지므로 타입 검사나 변환과 같은 번거로운 작업을 생략할 수 있음
4. 클래스나 메서드 내부에 사용될 데이터 타입의 안정성을 높일 수 있음
5. 자바에서 제네릭(Generics)은 클래스 내부에서 사용할 데이터 타입을 외부에서 지정하는 기법임
6. 객체별로 다른 타입의 자료가 저장될 수 있도록 함

## Generic 선언 및 생성

1. 제네릭 타입은 타입을 파라미터로 가지는 클래스와 인터페이스를 말함
2. 클래스 또는 인터페이스 이름 뒤에 <>(다이아몬드 연산자) 기호를 추가하고 안에 식별자 기호를 지정하여 파라미터화 할 수 있음
3. 이것을 마치 메서드가 매개변수를 받아 사용하는 것과 비슷하게 제네릭의 타입 매개변수(parameter)/타입 변수라고 부름
4. 형식
```java
public class 클래스명<T>{...}
public interface 인터페이스명<T>{...}
```

## 타입 파라미터 기호 네이밍

1. 제네릭 기호를 와 같이 써서 표현했지만 사실 식별자 기호는 문법적으로 정해진것은 없음
2. 다만 우리가 for문을 이용할 때 루프 변수를 i로 지정해서 사용하듯이, 제네릭의 표현변수를 T로 표현한다고 보면 됨(만일 두번째, 세번째 제네릭이 필요하다고 하면 S,U로 이어나감)
3. 명명하고 싶은대로 아무 단어나 넣어도 문제는 없지만, 대중적으로 통하는 통상적인 네이밍이 있으면 
개발이 용이해지기 때문에 암묵적인 규칙(convention)이 존재함
4. 타입 : 꼭 이렇게 쓰지않아도 되지만 사회적인 약속임

|표현변수|의미|
|---|---|
| T |타입(Type)|
| E |요소(Element)|
| K |키(Key)|
| V |값(Value)|
| N |숫자(Number)|

## 제네릭 사용시 주의사항

1. 제네릭 타입의 객체는 생성할 수 없음
    - 제네릭 타입 자체로 타입을 지정하여 객체를 생성하는 것은 불가능함
    - 예를 들어, T t  = new T( );는 생성불가
2. static 멤버에 제네릭 타입이 올 수 없음
    - static 변수의 데이터 타입으로 제네릭 타입 파라미터가 올 수는 없음
    - 왜냐하면 static 멤버는 클래스가 동일하게 공유하는 변수로서 제네릭 객체가 생성되기도 전에 이미 자료 타입이 정해져 있어야 하기 때문임
    - static 메서드의 반환타입으로 사용이 불가능함
    - static 메서드의 매개변수의 타입으로 사용이 불가능함
3. 제네릭으로 배열 선언 주의점
    - 기본적으로 제네릭 클래스 자체를 배열로 만들 수는 없음
    - 또한 제네릭 타입 파라미터에 클래스가 타입으로 온다는 것은 클래스끼리 상속을 통해 관계를 맺는 객체 지향 프로그래밍의 다형성의 원리가 그대로 적용이 된다는 뜻임
    - ex. Student<Integer>[ ] arr1 = new Student<>[10]; -> 사용x
4. 멀티타입 파라미터
    - 제네릭은 반드시 하나만 사용해야하는 법은 없음
    - 만일 타입 지정이 여러개 필요한 경우 2개,3개 얼마든지 만들 수 있음
5. 중첩타입 파라미터
    - 제네릭 객체를 제네릭 타입 파라미터로 받는 형식도 표현할 수 있음
    - ArrayList 자체도 하나의 타입으로서 제네릭 타입 파라미터가 될 수 있기 때문에 중첩 형식으로 사용할 수 있음
6. 제네릭 인터페이스
    - 인터페이스에도 제네릭을 적용할 수 있음
    - 단, 인터페이스를 구현(implements)한 클래스에서도 오버라이딩한 메서드를 제네릭타입에 맞춰서 똑같이 구현해야함
7. 제네릭 함수형 인터페이스 : 제네릭 인터페이스가 많이 사용되는 곳이 람다 함수형 인터페이스임
8. 제네릭 메서드 : 메서드의 선언부에 <T>가 선언된 메서드를 말하며, 직접 메서드에 <T>을 정함으로서 동적으로 타입을 받아와 사용할 수 있는 독립적으로 운용 가능한 제네릭 메서드라고 이해하면 됨

## 제네릭 타입 범위 한정하기

1. 제네릭에 타입을 지정해줌으로서 클래스의 타입을 컴파일 타임에 정하여 타입 예외에 대한 안정성을 확보하는 것은 좋지만 문제는 너무 자유롭다는 점임
2. 제네릭 타입 범위 한정하기
    - 제네릭에 타입을 지정해줌으로서 클래스의 타입을 컴파일 타임에 정하여 타입 예외에 대한 안정성을 확보하는 것은 좋지만 문제는 너무 자유롭다는 점
    - 형식
    ```java
    T extends [제한타입]
    ```
3. extends 키워드 다음에 올 타입은 일반 클래스, 추상 클래스, 인터페이스 모두 올 수 있음
4. 다중 타입 한정
    - 만일 2개 이상의 타입을 동시에 상속(구현)한 경우로 타입 제한을 하고 싶다면 &연산자를 사용하면 됨
    - 해당 인터페이스들을 동시에 구현한 클래스가 제네릭 타입의 대상이 되게 함
    - 단, 자바에서는 다중 상속을 지원하지 않기 때문에 클래스로는 다중 extends는 불가능하고 오로지 인터페이스로만이 가능함
5. 재귀적 타입 한정
    - 자기 자신이 들어간 표현식을 사용하여 타입 매개변수의 허용 범위를 한정시기키는것을 말함
    - 실무에선 주로 Comparable 인터페이스와 함께 쓰임

## 제네릭 형변환

1. 배열과 같은 일반적인 변수 타입과 달리 제네릭 서브 타입간에는 형변환이 불가능함
2. 자연스럽게 다형성이 적용될 것이라고 생각할 수 있지만 실상 제네릭은 전달받은 타입으로만 캐스팅이 가능함
3. 심지어 대입된 타입이 Object일지라도 불가능함
4. 제네릭 타입은 상하관계가 없음
    - 제네릭의 타입 변수(꺾쇠 괄호)끼리는 아무라 상속 관계에 놓인다 한들 캐스팅이 불가능함
    - 제네릭은 전달받은 타입만으로만 서로 캐스팅이 가능함
5. 제네릭 와일드 카드
    - 제네릭 간의 형변환을 성립되게 하기 위해서는 제네릭에서 제공하는 와일드카드 문법을 이용해야함
    - 와일드카드 사용방법
        - <?>_Unbounded Wildcards(제한 없음) : 타입 파라미터를 대치하는 구체적인 타입으로 모든 클래스나 인터페이스 타입이 올 수 있음
        - <? extends 상위타입>_Upper Bounded Wildcards(상위 클래스 제한) : 타입 파라미터를 대치하는 구체적인 타입으로 상위 타입이나 상위 타입의 하위 타입만 올 수 있음
        - <? super 하위타입>_Lower Bounded Wildcards(하위 클래스 제한) : 타입 파라미터를 대치하는 구체적인 타입으로 하위 타입이나 하위 타입의 상위 타입만 올 수 있음