# 람다식

1. JDK1.8부터 함수형 프로그래밍 '람다식(Lambda expression)'을 지원함
2. 람다식은 이름이 없는 익명 함수(anonymous function)를 만들기 위한 표현식을 말함
3. 자바는 객체를 기반으로 프로그램을 구현하는 객체 지향 프로그램임
4. 따라서 클래스를 먼저 생성하고, 클래스 안에 메서드와 객체를 만들어 사용해야 함
5. 하지만 함수형 프로그래밍은 객체 지향 프로그램과 달리 함수만을 구현하고 실행할 수 있는 개발방식임

## 람다식이 도입된 이유

1. 함수형 프로그래밍 방식
2. 자바에서는 함수형 프로그래밍 방식이 적용되지 않았음
3. 자바 공부할 때 함수는 클래스를 나누어서 작성했었음
4. 자바 -> 함수가 독립적이지 않음 -> 반드시 객체를 만들어서 호출
5. 자바는 클래스에 함수를 정의하고 객체를 통해 호출하는 방식을 사용하고 있음

## 람다식 문법

1. 람다식 문법은 기존의 자바 문법과는 달라서 객체 지향 프로그래밍에 익숙한 개발자들은 다소 생소할 수 있음
2. 하지만 문법이 매우 간결해지고, 원하는 결과를 쉽게 집계할 수 있어 익숙해지면 큰 장점이 있음
3. 메서드의 이름과 반환 타입을 제거하고 화살표(->)를 이용해 구현함
4. 람다식 작성 1 : 소괄호 생략하기
    - 람다식 문법에서는 파라미터의 자료형을 생략할 수 있음
    - 파라미터가 한 개인 경우에는 소괄호도 생략할 수 있음
    - 그러나 파라미터가 두 개 이상일 경우에는 생략할 수 없음
5. 람다식 작성 2 : 중괄호 생략하기
    - 함수의 반환형이 void라면 중괄호도 생략할 수 있음
6. 람다식 작성 3 : return 생략하기
    - 중괄호 안의 구현 코드가 return문만 존재할 때는 중괄호와 return을 모두 생략할 수 있음
7. 형식
```java
    int add(int x, int y){
	return x+y;		            ->	(x,y) -> {return x + y}
	}
```

## 함수형 인터페이스

1. 객체 지향 프로그램에서 인터페이스를 사용하려면 인터페이스를 클래스에서 구현한뒤 사용해야 함
2. 람다식은 위와 같은 과정을 생략할 수 있음
3. 단, 람다식을 이용해 인터페이스를 사용할 경우, 인터페이스는 하나의 기능만을 정의할 수 있음
4. 람다식을 구현하기 위해서는 먼저 인터페이스를 만들고, 인터페이스에 람다식으로 구현할 메서드를 선언해야 함
5. 오직 하나의 추상 메서드가 선언된 인터페이스만이 람다식의 타겟 타입이 될 수 있는데 이러한 인터페이스를 '함수형 인터페이스'라고 함

# 컬렉션 프레임워크와 함수형 인터페이스

1. 컬렉션 프레임워크의 인터페이스에 다수의 디폴트 메서드가 추가 되었고 그 중 일부는 함수형 인터페이스를 사용함
    - 인터페이스 : 서비스의 가이드라인을 제공, 구현클래스에서 사용여부 상관없이 모든 추상메서드를 오버라이딩해야 함
    - default 메서드 : 인터페이스에 있는 구현메서드, 추상메서드와 다른 점은 body를 가지고 있다는 것임
2. ArrayList에 forEach()메서드가 있고 Consumer 라는 매개변수를 받음(자바 공식문서에서 검색해보면 FunctionalInterface라는걸 알 수 있음)
3. 그때문에 람다식으로 표현할 수 있음
4. 장점
    - 인터페이스에 기본 구현을 제공함으로써, 해당 인터페이스를 구현하는 클래스에서 모든 메서드를 재정의 할필요가 없게 됨
    - default메서드를 통해 인터페이스에서 다중 상속과 유사한 기능을 제공할 수 있게 됨
5. 함수형 인터페이스로 사용할 때 추상메서드는 무조건 하나여야 함(단, 디폴트메서드는 여러개여도 상관없음)

## java.util.function패키지

1. 대부분의 메서드는 타입이 비슷함
2. 매개변수가 없거나 한 개, 두 개, 반환값이 없거나 한 개임
3. 제네릭 메서드로 정의하면 매개변수나 반환 타입이 달라도 문제가 되지 않음
4. java.util.function 패키지에 일반적으로 자주 쓰는 형식의 메서드를 함수형 인터페이스로 미리 정의해 놓았음
5. 매번 함수형 인터페이스를 정의하기 보다는 가능하면 이 패키지의 인터페이스를 활용하는 것이 좋음
6. java.util.function 패키지의 주효 함수형 인터페이스

- 참고 :  타입문자 'T'는 'Type'을 'R'은 'Return Type'을 의미함

|함수형 인터페이스|추상메서드|설명|
|---|---|---|
|java.lang.Runnable|void( ) run( )|매개변수도 없고 반환값도 없음|
|Supplier|T get( )|매개변수는 없고 반환값만 있음|
|Consumer|void accept(T t)|Supplier와 반대로 매개변수만 있고, 반환값이 없음|
|Function<T,R>|R apply(T t)|일반적인 함수. 하나의 매개변수를 받아서 결과를 반환|
|Predicate|boolean test(T t)|조건식을 표현하는데 사용됨. 매개변수는 하나. 반환값은 boolean|

7. 매개변수가 두 개인 함수형 인터페이스

- 매개변수가 두 개인 함수형 인터페이스는 이름 앞에 접두사 'Bi'가 붙음
- 참고 : Supplier는 매개변수는 없고 반환값만 존재하는데, 매서드는 두 개의 값을 반환할 수 없으므로 BiSupplier가 없음
- 두 개 이상의 매개변수를 갖는 함수형 인터페이스가 필요하면 직접 만들어 써야 함

|함수형 인터페이스|메서드|설명|
|---|---|---|
|BiConsumer<T,U>|void accept(T t, U u)|두개의 매개변수만 있고 반환값이 없음|
|BiPredicate<T,U>|boolean test(T t, U u)조건식을 표현하는데 사용됨. 매개변수는 둘, 반환값은 boolean|
|BiFunction<T,U,R>|R apply(T t, U u)|두 개의 매개변수를 받아서 하나의 결과를 반환|

## 람다식의 합성과 결합_Function의 합성과 Predicate의 결합

1. 합성
    - 두 람다식을 합성해서 새로운 람다식을 만들 수 있음
    - f.andThen(g) - 함수 f를 먼저 적용하고 그 다음에 함수 g를 적용함
    - f.compose(g) - g를 먼저 적용하고 f를 적용함
    - Function.identity( ) - 함수를 적용하기 이전과 동일한 항등함수, x -> x

2. 결합
    - Predicate를 and( ), or( ), negate( )로 연결해서 하나의 새로운 Predicate로 결합할 수 있음
    - Predicate의 끝에 negate()를 붙이면 조건식 전체가 부정이 됨
    - static 메서드인 isEqual( )은 두 대상을 비교하는 Predicate를 만들때 사용함
    - 논리를 가지고 연산을 하는 논리연산자와 비슷함


## 메서드 참조

1. 메서드 참조는 말 그대로 메서드를 참조해서 매개변수의 정보 및 리턴 타입을 알아내어, 람다식에서 불필요한 매개변수를 제거하는 것임
2. 람다식이 하나의 메서드만 호출하는 경우에는 메서드 참조(method reference)라는 방법으로 람다식을 간결하게 할 수 있음
3. 하나의 메서드만 호출하는 람다식은 클래스이름::메서드이름 또는 참조변수::메서드이름으로 바꿀 수 있음
4. 참조 타입 : 기본 타입(byte,short,char,int,long,float,double,boolean)을 제외하고 배열, 열거, 클래스,인터페이스 등을 말함. 참조 타입의 변수에는 객체(메모리)의 주소가 저장 됨
5. 정적 메서드 참조
    - 클래스명::정적메서드명 ex. (x,y)-> Math.max(x,y);
    - 함수 형태를 보면 리턴값 자체가 또다른 Math 클래스의 메서드를 호출하는 것 뿐임
    - 람다 함수 매개변수 역시 그대로 max() 메서드의 매개변수로 들어가기 때문에 코드 중복이 발생함
    - 만약 Math:max 메서드 참조를 변수에 담고 싶다면 함수평 인터페이스인 IntBinaryOperator를 사용해야 함
    - 두 개의 int형 입력값을 받아 int값을 리턴하는 함수 applyAsInt(int,int)를 가지고 있기 때문임
    - 인스턴스 메서드 참조 : 객체명::메서드명