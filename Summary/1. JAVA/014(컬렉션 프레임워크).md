# 컬렉션 프레임워크(Collection FrameWork)

1. 배열은 한번 정한 크기를 변경하거나 삭제할 수 없음
2. 또한 별도의 기능이 없기 때문에 직접 index를 이용해 데이터를 저장해야 함
3. 자바는 이러한 불편함을 해결하기 위해 피룡한 자료구조를 미리 구현하여 java.util 패키지에서 제공하고 있으며, 이를 '컬렉션 프레임워크'라고 함
4. 컬렉션은 기존에 있던 자료구조 List(리스트), Queue(큐), Tree(트리) 등의 자료구조를 의미함
5. 프레임워크는 클래스와 인터페이스를 묶어 놓은 개념임
6. 즉, 컬렉션 프레임워크란 기존에 존재했던 자료 구조에 인터페이스로 설계된 기능을 클래스를 통해 제공하여 데이터 관리에 용이한 자료 구조 객체를 구조화한 것임
7. 인터페이스

|자료구조|설명|특징|대표구현클래스|
|---|---|---|---|
|List|순서가 있는 데이터의 집합|중복허용|ArrayList, LinkedList|
|Set|순서를 유지하지 않는 데이터의 집합|중복불가|HashSet, LinkedHashSet|
|Map|키(Key)와 값(Value)의 쌍으로 이루어진 데이터의 집합|순서유지안함, 키중복 안됨, 값중복 가능|HashMap, LinkedHashMap, Properties|
8. List와 Set인터페이스는 모두 Collection 인터페이스를 상속받음
9. Map 인터페이스는 구조상 차이로 별도로 정의됨

## List컬렉션

1. List는 배열과 유사한 자료 구조로 중복이 허용되면서 저장 순서가 유지되는 구조를 제공함
2. 즉 배열처럼 index를 사용해 데이터를 저장하고 찾게 됨
3. 배열과는 다르게 크기의 제한이 없으며 삽입,삭제,변경의 기능이 자유로움
4. 데이터의 크기를 특정할 수 없는 다량의 데이터를 저장할 때 용이하게 사용할 수 있는 자료구조임
5. List가 제공하는 주요 메서드

|메서드|동작|기능|
|---|---|---|
|void add(E e)|삽입|데이터를 순차적으로 삽입|
|void add(int index,E e)|중간삽입|index 위치에 삽입|
|void set(int index,E e)|치환|원하는 index 위치의 값 변경|
|E get(int index)|반환|선택된 index위치의 값 반환|
|void remove(int index)|삭제|선택된 index위치의 값 삭제|
|void clear( )|전체삭제|모든 데이터 삭제|
|int size( )|크기|저장된 데이터의 개수 반환|
|boolean contains(Object o)|크기|데이터 존재 여부 확인|

### 반복자(Iterator)

1. Iterator는 List컬렉션에서 제공하는 인터페이스로 사전적인 의미로는 '반복하다'라는 뜻을 지니고 있음
2. List 컬렉션의 요소를 순회하여 하나씩 추출하는데 사용함
3. 반복자라고도 불리는 Iterator객체는 선언된 컬렉션 객체에서 가져와 사용됨
4. Iterator메서드
    - boolean hasNext( ) : 다음에 순회할 데이터 유뮤 확인하며 가져올 객체가 있으면 true,없으면 false를 반환
    - E next( ) : 다음 위치의 데이터로 이동하여 반환

### ArrayList

1. ArrayList는 가장 많이 사용하는 List인터페이스의 대표적인 구현 클래스임
2. JDK 1.2부터 제공된 ArrayList는 내부적으로 배열을 이용해 구현되어 배열과의 호환성이 좋은 자료구조임
3. 형식
```java
List<데이터 타입> list = new ArrayList<데이터 타입>();
```
4. JDK 1.7이후부터는 Collection의 선언이 간소화되었음
```java
List<데이터 타입> list = new ArrayList<>();
```
- 우측의 생성자를 통한 선언시 제네릭을 생략할 수 있음

### ArrayList에 데이터 저장

1. add(E e);
    - 기존에 존재하는 마지막 데이터 뒤에 차례대로 삽입됨
    - 삽입시에는 index가 부여되며 배열과 마찬가지로 순차적으로 부여됨
2. add(int index, E e)
    - 원하는 위치에 데이터를 삽입할 수 있음
    - 그러나 연속성이 없어 순서를 부여해 삽입하는 것은 불가능함
    - 만약 데이터가 3개 들어있는 List가 있다면, 해당 리스트에서 index가 1인, 즉 2번째 위치에 데이터를 삽입할 경우 index위치 0과 1 사이에 값이 들어가서 삽입된 값은 1이 되고, 기존 1의 값은 2가 됨
    - 하지만 추가를 원하는 위치가 연속성이 없는 위치라면 문법적으로 오류가 발생하지 않지만 실행 시 오류가 발생함
3. ArrayList데이터 치환
    - List에 저장된 데이터를 변경할 수 있음
    - 변경을 원하는 index위치와 치환할 값 또는 객체를 지정하면 해당 위치의 값이 변경됨
    - 형식
    ```java
    void set(int index, E value);
    ```
4. ArrayList데이터 삭제
    - List의 데이터 삭제는 단지 데이터만 삭제되는 것이 아니라 해당 위치의 공간까지 삭제됨
    - 배열의 경우 공간이 생성되면 삭제할 수 없지만, List는 원하는 위치의 공간을 삭제할 수 있으며
    빈 공백을 메우기 위해 뒤의 데이터들이 앞으로 이동
    - 데이터를 삭제할 때는 remove( )메서드를 이용함
    - 해당 메서드는 remove(int index)와 remove(Object o)두가지가 있는데 remove(int index)는 index를 이용해, 특정 위치의 데이터를 삭제하고 remvoe(Object o)는 저장한 데이터를 삭제함

### LinkedList

1. 데이터와 다음 데이터의 주소를 가지는 노드(Node)객체가 연결되어 데이터를 저장하는 자료구조임
2. ArrayList와 마찬가지로 List컬렉션의 구현 클래스이므로 사용할 수 있는 메서드가 대부분 동일함
3. ArrayList는 배열을 이용해 데이터를 저장하는 반면, LinkedList는 Node라는 객체를 생성하여 인접 데이터를 링크해서 체인처럼 관리함
4. LinkedList는 node라는 구조를 가진 클래스들이 체인 형식으로 이어져있음
5. 노드는 데이터와 주소를 가지는데, 주소는 다음에 오는 노드의 값을 가지고 있이서 연결 구조를 이룸
6. 따라서 index가 실제 존재하지는 않지만, 서로 연결되어있기 때문에 순서를 알 수 있음

## Set

1. Set컬렉션은 List컬렉션과는 다르게 객체의 저장 순서를 저장하지 않음
2. Set컬렉션은 수학의 집합과 유사한 개념을 지니고 있음
3. List컬렉션은 데이터 저장 시 중복을 서용하지만 Set컬렉션은 데이터의 중복을 허용하지 않음
4. 데이터를 저장할 때 순서, 즉 index를 부여하지 않기 때문에 데이터가 입력된 순서대로 출력된다는 보장이 없음
5. Set인터페이스에서 제공하는 메서드
    - void add(E e) : 데이터를 순차적으로 삽입
    - void remove(Object o) : 선택된 값 삭제
    - void clear( ) : 모든 데이터 삭제
    - int size( ) : 저장된 데이터의 개수 반환
    - boolean contains(Object o) : 데이터 존재 여부 확인
6. HashSet : HashSet클래스는 Set인터페이스에서 가장 많이 사용되는 클래스로 인터페이스를 상속받아 구현됨
7. HashSet 데이터 저장
    - HashSet은 데이터를 저장할 때 순서를 부여하지 않고 데이터의 중복을 허용하지 않음
    - 동일한 값, 또는 객체를 허용하지 않는다는 의미임
    - 동일한 객체란, 꼭 같은 타입의 객체를 의미하는 것은 아님
    - HashSet은 데이터를 객체의 hashCode( )값을 호출하여 비교하고, 같으면 equals( )메서드를 호출하여 다시 비교해 두 객체가 같음을 증명함

## Map

1. Map은 List,Set과 달리 Map 인터페이스가 별도로 존재하며, 데이터를 List계열의 컬렉션과 다르게 처리함
2. Map인터페이스는 데이터를 Key(키)와 Value(값)로 구분하여 저장하는 방식(Key-value 방식)을 사용함
3. 비유적으로는 색깔별로 열쇠, 자물쇠로 설명하기도 함
4. map구조는 key를 통해서 값을 검색해내므로 많은 양의 데이터를 조회하는데 있어서 매우 뛰어난 성능을 발휘함
5. HashMap : map을 구현하고 있는 자식 클래스에서 가장 많이 사용하는게 hash map임

## TreeSet

1. TreeSet은 이진탐색트리 중에서도 성능을 향상시킨 레드-블랙 트리(Red-Black Tree)로 구현되어 있음
2. 레드 블랙 트리는 부모노드보다 작은 값을 가지는 노드는 왼쪽 자식으로, 큰 값을 가지는 노드는 오른쪽 자식으로 배치함
3. 데이터의 추가나 삭제 시 트리가 한쪽으로 치우쳐지지 않도록 균형을 맞추어줌

