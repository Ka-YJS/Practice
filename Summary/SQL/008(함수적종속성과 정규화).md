# 함수적 종속성

1. 어떤 릴레이션R이 있을 때 X와 Y를 각각 속서으이 부분집합이라고 가정했을 때
    - X값을 알면 Y값을 바로 식별할 수 있음
    - X값에의해 Y값이 달라질 때, Y는 X의 함수적 종속이라고 함
    - 이 경우를 X를 결정자, Y를 종속자라고 함
    - 기호로는 X -> Y로 표현할 수 있음
2. 종속관계 종류
    - 완전 함수적 종속
    - 부분 함수적 종속
    - 이행 함수적 종속

## 완전 함수적 종속

1. 종속자가 기본키에만 종속 -> 기본키가 여러개일 경우엔 기본키를 다 알아야 다른것도 알 수 있음
2. 기본키가 여러속성으로 구성되어있을 경우, 기본키를 구성하는 모든 속성이 포함된 기본
3. 키의 부분집합에 종속된 경우

## 부분 함수적 종속

1. 테이블(릴레이션)에서 종속자가 기본키가 아닌 기본키를 구성하는 속성 중 일부에만 종속
    - ex. 기본키가 두개일 때, 두개 전부가 아닌 그 중 한개만 종속하는 경우
2. 기본키가 여러 속성으로 구성되어 있을 경우, 기본키를 구성하는 속성 중 일부만 종속되는 경우

## 이행 함수적 종속

1. 테이블(릴레이션)에서 X, Y, Z라는 3개의 속성이 있을 때, X -> Y, Y -> Z란 종속관계까 있을 경우 X -> Z가 성립될 때 이행 함수적 종속이라고 함
2. 즉, X를 알면 Y를 알고, 그를 통해 Z를 알 수 있는 경우


# 정규화

1. 목표 : 테이블 간에 중복된 데이터를 허용하지않는 것
2. DB의 저장용량 역시 줄일 수 있음
3. 정규화에는 총 5단계가 있음
    - 제 1 정규화
    - 제 2 정규화
    - 제 3 정규화
    - 제 4 정규화
    - BCNF 정규화
    - 제 5 정규화
4. 암기방법 : 두부이걸다줘?로 암기하기 -> 도부이결다조
5. 문제풀이1
- Q. 다음보기 중 3차 정규화에 대한 설명으로 바른 것은?
- A1. 해당 릴레이션에 기본키를 식별한다.
- A2. 기본키가 하나 이상의 키로 되어있는 경우에 부분함수 종속성을 제거한다.
- A3. 조인으로 발생하는 종속성을 제거한다.
- A4. 이행함수 종속성을 제거한다.
- 정답 : A4 
5. 문제풀이2
- Q. 다음의 정규화단계에서 주식별자와 관련성이 가장 낮은 것은?
- A1. 제 1 정규화
- A2. 제 2 정규화
- A3. 제 3 정규화
- A4. BCNF 
- 정답 : A3

## 제 1 정규화(도)

1. 테이블의 컬럼이 원자값(하나의 값)을 갖도록 테이블을 분해하는 것 -> 도메인이 원자값
2. 예를들어, 여러명의 선수의 취미생활을 테이블로 작성했을 때, 추신수와 박세리는 여러개의 취미를 갖고있기때문에 제1정규화를 만족하지 못함

## 제 2 정규화(부)

1. 부분함수적 종속제거
2. 제1정규화가 완료된 테이블에 대해 완전함수종속을 만족하도록 테이블을 분해하는 것
3. 기본키의 부분집합이 결정자가되면 안된다는 것
4. 기본키가 한가지 속성으로 구성되어있다면, 제2정규화는 생략함

## 제 3 정규화(이)

1. 제2정규화를 진행한 테이블에 대해 이행함수적종속을 없애도록 테이블을 분해하는 것
2. A -> B / B -> C 일때, A -> C가 성립되는 것을 이행함수적종속이라고 함

## BCNF 정규화(결)

1. 제3정규화를 진행한 테이블에 대해 모든 결정자가 후보키가 되도록 테이블을 분해하는 것
2. 결정자가 기본키가 아닌 것을 제거 -> 테이블을 분해

## 제 4 정규화(다), 제 5 정규화(조)

1. 제 4 정규화 : 다치종속 제거
2. 제 5 정규화 : 조인종속 제거

## 반정규화

1. 성능향상을위해서 데이터중복을 허용하고 조인(여러테이블에서 검색)을 줄이는 방법
2. 조회(SELECT)속도 향상되지만, 모델의 유연성이 낮아짐
3. 반정규화를 사용하는 이유
    - 정규화수행 후 성능이 낮아진 경우(속도가 느려진 경우)
    - 다량의 범위를 자주 처리해야하는 경우
    - 특정범위의 데이터만 자주 처리되는 경우
    - 요약/집계정보가 자주 요구되는 경우
4. 절차
    - 대상 조사 및 검토 -> 반정규화 대상을 조사
    - 다른 방법 검토 -> 클러스터링, 뷰, 인덱스 튜닝, 파티션 등 검토
    - 반정규화 수행 -> 수행
5. 기법
    - 계산된 속성 추가
    - 테이블 수직 분할 : 하나의 테이블에서 두개로 분할 -> 속성을 기준으로 분할
    - 테이블 수평 분할 : 하나의 테이블에서 두개로 분할 -> 튜플을 기준으로 분할
6. 파티션(Partition)
    - 논리적으로 하나의 테이블이지만, 여러 개의 파일에 분산 저장
    - Range Partition : 범위 기준
    - List Partition : 값 기준
    - Hash Partition : 해시 함수 기준
    - Composite(여러 개를 함께 씀) Partition : 범위+해시 함수 기준
    <br>*해시 : 어떤 임의의 길이의 값을 넣었을 때 16진수에 해당하는 값이 나오는 것
7. 테이블의 병합
    - 1:1 관계 테이블 병합
    - 1:N 관계 테이블 병합(많은 양의 데이터 중복 발생)
    - 슈퍼 타입과 서브 타입 관계 테이블 병합(부모자식관계를 말함)
    - OneToOne Type : 개별 테이블로 도출
    - Plus Type : 슈퍼타입과 서브 타입 테이블로 도출
    - Single Type : 하나의 테이블로 도출
8. 문제풀이1
- Q. 병렬데이터베이스 환경 중 수평분할에서 활용되는 기법이 아닌것은?
- A1. 라운드 로빈
- A2. 범위분할
- A3. 예측분할 
- A4. 해시분할
- 정답 : A3
9. 문제풀이2 
- Q. 다음은 ABC증권회사의 회원정보를 모델링한 것이다. 회원정보는 수퍼타입이고, 개인회원과 법인회원 정보는 서브타입니다. 애플리케이션에 회원정보를 조회하는 경우는 항상 개인회원과 법인회원을 동시에 조회하는 특성이 있을 때 수퍼타입과 서브타입을 변환하는 방법으로 가장 올바른 것은? 
![012_ST](https://github.com/user-attachments/assets/f4a4f2c4-5489-464f-88af-25fe6cceb260)
- A1. ONE TO ONE
- A2. PLUS TYPE
- A3. SIGLE TYPE
- A4. 정답없음
- 정답 : A3
    

