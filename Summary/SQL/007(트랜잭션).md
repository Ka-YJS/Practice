# 트랜잭션

1. 데이터베이스의 상태를 변화시키기 위해서 수행하는 작업의 단위(분리될 수 없는 최소 단위)
2. 질의어(SQL)를 이용하여 데이터베이스에 접근하는 것을 의미
    <br>-> 접근 : SELECT제외, 데이터베이스의 상태가 변화함
3. 작업의 단위는 SQL한 문장이 아님
4. 작업 단위는 많은 SQL명령문들을 사람이 정하는 기준에 따라 정하는 것을 의미함
5. 트랜잭션 설계를 잘하는 것이 데이터를 다루는 것에 많은 이점이 있음
6. 예시 : 게시판
    - 게시판 사용자는 게시글을 작성하고, 올리기버튼을 누름
    - 그 후에 다시 게시판에 돌아왔을 때, 자신의 글이 포함된 게시판을 보게 됨
    - 이 상황을 데이터베이스 작업으로 옮기면, 사용자가 올리기버튼을 눌렀을 시, INSERT문을 사용하여 사용자가 입력한 게시글의 데이터를 삽입함
    - 그 후에 게시판을 구성할 데이터를 다시 SELECT하여 최신정보로 유지함
    - 현재 작업 단위는 INSERT문과 SELECT문을 합친 것
    <br>-> 이러한 작업의 단위를 하나의 트랜잭션이라고 함

## 트랜잭션 특징

1. 원자성(Atomicity)
    - 원자와 같이 데이터베이스 연산들이 나눌수도, 줄일수 없는 하나의 유닛으로서 취급
    - 트랜잭션이 데이터베이스에 모두 반영(commit)되던가, 아니면 전혀 반영되지 않아야 한다는 것
    - 트랜잭션은 사람이 설계한 논리적인 작업 단위로서, 일 처리는 작업단위 별로 이루어져야 사람이 다루는 데 무리가 없음
    - 만약 트랜잭션 단위로 데이터가 처리되지 않는다면, 설계한 사람은 데이터처리시스템을 이해하기 힘들 뿐만 아니라, 오작동했을 시 원인을 찾기가 매우 힘들어질 것임
2. 일관성(Consistency)
    - 트랜잭션의 작업처리결과가 항상 일관성이 있어야 한다는 것
    <br>-> 내가 트랜잭션을 진행할 때, 나는 내 시점 그대로를 진행해야 함
    - 데이터베이스의 트랜잭션이 제약조건, cascades, triggers를 포함한 정의된 모든 조건에 맞게 데이터 값이 변경됨 
    - 트랜잭션이 진행되는 동안에 데이터베이스가 변경되더라도 업데이트된 데이터베이스로 트랙잭션이 진행되는 것이 아님
    - **처음에 트랜잭션을 진행하기위해 참조한 데이터베이스로 진행**
    - 이렇게해서 각 사용자가 일관성있는 데이터를 볼 수 있는 것
3. 독립성(고립성, Isolation)
    - 둘 이상 트랜잭션이 동시에 실행되고 있을 경우 어떤 하나의 트랜잭션이라도, 다른 트랜잭션의 연산에 끼어들 수 없다는 점(상호간에 간섭은 절대 안됨)
    - 하나의 특정 트랜잭션이 완료될 때까지, 다른 트랜잭션이 특정 트랜잭션의 결과를 참조할 수 없음
    - 특정 DBMS에서 다수의 유저들이 같은 시간에 같은 데이터에 접근하였을 때 수행중인 트랜잭션이 완료될 때 까지 다른 트랜잭션의 요청을 막음으로서 데이터가 꼬이는걸 방지함
4. 지속성(영속성, Durability)
    - 완료(commit)된 트랜잭션은 데이터베이스에 영구적으로 보존되어야 함
    - 트랜잭션 실행이 성공적일 때, 그 트랜잭션이 갱신한 데이터베이스 내용은 영구적으로 저장됨
5. 문제풀이
- Q. 다음 보기 중 트랜잭션의 특징에 대한 설명 중 올바른 것은?
- A1. 원자성(Atomicity) : 트랜잭션 내의 모든 문장이 모두(ALL)반영되거나, 혹은 일부가 반영되어야 한다.
- A2. 영속성 : 트랜잭션의 수행으로 데이터베이스의 무결성은 보장될 수 없다.
- A3. 일관성 : 여러 개의 트랜잭션들이 동시에 수행될 때, 한 개의 트랜잭션의 복사본을 유지한다.
- A4. 지속성 : Commit이 완료되면 영구적으로 저장을 보장해야 한다.
- 정답 : A4


## 트랜잭션 상태

1. Active : 활성
2. Partially Committed : 부분완료 -> 아직 연산 안끝남
3. Committed : 연산완료
4. Failed : 실패
5. Aborted : 연산철회 -> 원래상태로 되돌리는 것


## 트랜잭션 병행제어

1. 여러 개의 트랜잭션을 제어하는 경우 일관성이 없고, 다른거에 영향이 없음
2. 교착상태(Dead Lock)
    - 막히는 고속도로를 생각하면 됨
    - 자원을 할당받아야하는데 할당받지 못해서 무한정 대기 상태
    - 교착상태를 예방/회피하기위해서는 Locking이나 TimeStamp를 하면 됨
3. Locking
    - DB에부터 Tuple까지 Locking을 걸어두는 상태(Locking단위 : DB~Tuple)
    - 다른 트랜잭션이 접근할 수 없게 만듦
    - 크기가 큼 -> 관리하기가 쉬움(오버헤드가 낮아짐 -> 연산이 적어짐)
    <br>but. 병행성(동시성)수준이 낮아짐
    - 크기가 작음 -> 오버헤드가 증가함 but. 병행성(동시성)수준이 높아짐(여러개의 트랜잭션 진행가능)
    <br>*오버헤드란? 컴퓨터에서 어떤 작업을 수행할 때, 추가적으로 필요한 부가적인 작업이나 비용을 말함
4. Time Stamp
    - 시간을 정해놓고 순서대로 쓰기
    - but. 순서를 정해놓고 쓰기때문에 직렬의 가능성이 존재함
5. 병행제어를 하지않을 경우에 생기는 문제점
    - 분실된 갱신 : 2개의 트랜잭션을 갱신(업데이트)했을 때 하나아 분실됨
    - 모순성 : 일관성이 깨짐(같은 테이블에서 여러 개의 트랜잭션이 실행되면서 연산이 깨짐)
    - 연쇄복제 : 원래하던 트랜잭션을 실행중에 다른 트랜잭션이 들어오게 되면서 원래 하던 트랜잭션이 깨지며, 다른 트랜잭션은 문제가 없음에도 같이 깨짐
    - 비완료 의존성 : 철회를해서 회복도중 완료가 되지않은 상태에서 고장나있는 상태를 참조함

## 트렌잭션 연산

1. TCL
    - DCL안에 TCL이 들어가있으며, TCL은 트랜잭션을 제어하기위해 따로 이름을 만든 것일 뿐임
    - 트랜잭션을 제어하는 명령어로, Commit과 Rollback이 있음
2. Commit
    - 하나의 트랜잭션이 성공적으로 끝났고, 데이터베이스가 일관성있는 상태에 있을 때, 하나의 트랜잭션이 끝났다는 것을 알려주기위해 사용하는 연산
3. Rollback : 하나의 트랜잭션처리가 비정상적으로 종료되어 트랜잭션의 원자성이 깨진경우, 트랜잭션을 처음부터 다시 시작하거나 트랜잭션에서 부분적으로만 연산이 완료된 결과를 다시 취소시키는 연산

### TCL_COMMIT

1. 트랜잭션 처리가 정상적으로 종료되어 **트랜잭션이 수행한 변경내용을 데이터베이스에 반영하는 연산**
2. 내용을 변경한 트랜잭션이 완료되면 그 트랜잭션에의해 데이터베이스를 새롭게 일관된 상태로 변경되며, 이 상태에서는 시스템오류가 발생하더라도 취소되지않음
3. COMMIT명령어 같은 경우에는 데이터베이스에서 자동으로 실행해줌
4. 그 예시로 COMMIT명령어를 따로 입력해주지않아도 데이터베이스에 값을 저장하면 그대로 반영됨
5. DML로 변경된 데이터를 데이터베이스에 적용할 때 사용
    - INSERT,UPDATE,DELETE문 등을 사용한 후 변경 작업을 데이터베이스에 반영하기 위해 사용
    - COMMIT문 사용시 이전 데이터는 영원히 지워짐
    - COMMIT문 사용시 모든 사용자가 변경된 데이터 확인 가능
    - SQLServer는 기본적으로 AUTO COMMIT모드이므로 자동으로 COMMIT을 수행함(DML문이 성공하면 자동으로 COMMIT을 실행함)
    - COMMIT 실행시 하나의 트랜잭션 과정을 종료
  <br>→ COMMIT이 실행되기 전에 다른 사용자가 완료되지 않은 데이터를 보거나 변경할 수 없음

### TCL_ROLLBACK

1. 하나의 트랜잭션 처리가 비정상적으로 종료되어 데이터베이스의 일관성이 깨졌을때, **트랜잭션이 행한 모든 변경작업을 취소하고 이전상태로 되돌리는 연산**
2. ROLLBACK연산 시 해당 트랜잭션을 받았던 자원과 잠금을 모두 반환하고, 재시작 또는 폐기가 됨
3. ROLLBACK연산 시 마지막 COMMIT이후의 작업으로 돌아가는데, 이때 만약 COMMIT을 하지않았다면 모든 작업이 사라짐(트랜잭션 자체가 사라지는 것이 아닌 현재 하고있던 연산이 지워짐)
4. DML로 변경된 데이터를 변경 이전 상태로 되돌릴 때 사용
    - 데이터에 대한 변경사항 취소
    - ROLLBACK문 사용시 이전 데이터 다시 재저장 -> COMMIT되지 않은 상위 트랜잭션을 모두 ROLLBACK시킴
    - ROLLBACK문 사용시 관련 행의 잠금(LOCKING)이 풀려 다른 사용자들이 데이터 변경 가능
    - SQL Server는 기본적으로 AUTO COMMIT모드이므로 자동으로 COMMIT, 오류가 발생하면 자동으로 ROLLBACK처리
5. 형식
```SQL
ROLLBACK TO 'SAVEPOINT_NAME';
```

### TCL_SAVEPOINT

1. **현재 트랜잭션을 시점별로 작게 분할하는 명령어**로 트랜잭션 내부에서만 쓰임
2. 저장된 SAVEPOINT는 ROLLBACK TO SAVEPOINT문을 사용하여 지정한 곳(시점)까지 ROLLBACK할 수 있음
3. 여러개의 SQL문을 수반하는 트랜잭션의 경우, 사용자가 트랜잭션 중간 단계에서 SAVEPOINT를 지정할 수 있음
4. SAVEPOINT는 ROLLBACK과 함께 사용하며, 현재 트랜잭션내의 특정 SAVEPOINT까지 ROLLBACK할 수 있음(ROLLBACK없이 혼자 쓰이지않음)
5. 오류 복구 처리에 효과적인 방법 -> 전체 트랜잭션을 ROLLBACK하지 않고도 오류 복귀 가능
6. 복잡한 대규모 트랜잭션에서 에러가 발생했을 때 주로 사용되며, 복수의 저장점을 정의가능함

7. 형식
```SQL
SAVEPOINT 포인터명;
```

8. 주의사항
    - SAVEPOINT후에 COMMIT연산을 하게된다면 COMMIT 연산 이전에 만든 SAVEPOINT들은 모두 사라짐
    - SAVEPOINT는 여러개 생성가능함

### TCL_START TRANSACTION

1. 트랜잭션을 시작할 때 사용하는 명령
2. 이 명령어 외에 BEGIN이나 BEGIN WORK를 입력해도 됨