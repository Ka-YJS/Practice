# 컨트롤러 레이어 : 스프링 REST API 컨트롤러

1. HTTP는 GET/POST/PUT/DELETE/OPTIONS 등과 같은 메서드와 URI를 이용해 서버에 HTTP요청을 보낼 수 있음
2. 그렇다면 서버는 이 요청을 받은 후 어떻게 처리해야 할까?
<br>예시

```JAVA
GET /test HTTP/1.1
Host : localhost:8080
Content-Type: application/json
Content-Length : 17
{
	"id"123
}
```
3. localhost:8080에게 http GET메서드를 이용해 test라는 리소스를 요청한다는 뜻임
4. 서버는 자기 주소를 제외한 /{리소스}부분을 이해하고, 또 이 요청이 어떤 HTTP메서드를 이용했는지 알아야 함
5. 그 후 해당 리소스의 HTTP메서드에 연결된 메서드를 실행해야 함

## 레이어드 아키텍처와 MVC패턴

|레이어드 아키텍처|MVC패턴|
|---|---|
|소프트웨어 전반에 계층을 나눔|표현계층에서 주로 사용|
|표현, 서비스, 영속계층|Model, View, Controller|
|기능별로 책임의 분리|UI처리와 데이터의 흐름만 분리|
|계층별 의존성 최소화||
|계층간 상호작용을 통해 데이터가 흐름|Controller가 입력받아 Moder과 View간의 흐름을 제어함|


## 스프링 부트 스타터 웹 -> 스타터팩 같은 것임

1. Spring Boot 프로젝트에서 웹 애플리케이션 개발을 쉽게 할 수 있도록 도와주는 의존성 패키지임
2. Spring Boot에서 제공하는 다양한 "스타터" 중 하나로, REST API, 웹 애플리케이션, MVC 패턴 등을 빠르고 간편하게 개발할 수 있게 해줌
3. 주요 기능 : 내장된 톰캣 서버, Spring MVC, RESTful API, 의존성 자동 설정, Jackson 통합
4. 내장된 톰캣 서버
  - 톰캣(Tomcat)은 스프링 부트에서 기본적으로 포함된 서블릿 컨테이너로, 개발자가 별도의 서버 설정 없이 애플리케이션을 실행할 수 있게 해줌
  - 내장된 톰캣 서버가 자동으로 포함되어 jar 파일로 패키징된 애플리케이션을 쉽게 실행할 수 있음
5. Spring MVC
  - Spring MVC를 기본적으로 지원함
  - 이걸 통해 HTTP 요청을 처리하고, 클라이언트에게 응답을 반환하는 구조를 쉽게 구현할 수 있음
  - Spring MVC는 주로 컨트롤러(@Controller, @RestController), 모델(데이터를 다루는 객체), 뷰(View)(HTML, JSON 등의 출력 형식)로 구성됨
6. RESTful API
  - @RestController, @RequestMapping 같은 애노테이션을 사용해서 간단하게 REST 엔드포인트를 정의할 수 있음
  - JSON, XML 같은 형식으로 데이터를 주고받는 API 서버를 빠르게 만들 수 있음
7. 의존성 자동 설정
  - 웹 애플리케이션을 개발하기 위한 필수 의존성을 모두 포함하고 있음
  - 예를 들어, spring-web, spring-webmvc, jackson(JSON 변환) 등 웹 개발에 필요한 라이브러리들이 자동으로 포함됨
  - 개발자는 별도로 각 라이브러리를 설정할 필요 없이, 스타터 의존성을 추가하는 것만으로도 웹 프로젝트를 바로 시작할 수 있음
8. Jackson 통합
  - Jackson은 Java 객체를 JSON으로 변환하고, 그 반대로도 변환할 수 있는 라이브러리임
  - Spring Boot Starter Web은 Jackson을 기본적으로 포함하여, REST API에서 쉽게 JSON 데이터 처리를 할 수 있도록 도와줌



## 다양한 어노테이션 

1. @RestController
  - REST API 개발에 최적화
  - 웹 페이지가 아닌 데이터를 반환하는 컨트롤러로 사용됨
  - HTML 같은 뷰 페이지를 반환하는 대신, JSON이나 XML 형식의 데이터를 반환하는 RESTful API를 제공하는 데 적합함
  - @Controller와 @ResponseBody의 결합
  - @RestController는 @Controller와 @ResponseBody의 결합임
  - 즉, 클래스에 @RestController를 붙이면 모든 메서드에 자동으로 @ResponseBody가 적용됨
  - @ResponseBody는 메서드의 반환 값을 HTTP 응답 바디로 직렬화해 클라이언트에게 전달함
  - 따라서 데이터를 JSON, XML 형식으로 변환해 반환함
2. @ResponseBody
  - 컨트롤러 메서드의 반환 값을 HTTP 응답의 바디에 직접 포함시키는 데 사용됨
  - 뷰(HTML 파일) 같은 템플릿을 반환하지 않고, 주로 JSON 또는 XML 같은 데이터를 클라이언트에게 직접 반환하는 데 사용됨
3. @ResponseBody_주요기능
  - 데이터 직접 반환
  - HTTP 응답 바디로 직렬화해서 클라이언트에 전송함
  - 반환되는 데이터는 보통 JSON 형식으로 변환됨
  - 주로 REST API에서 데이터를 클라이언트에 반환할 때 사용되며, JSON 또는 XML 형식의 응답을 쉽게 처리할 수 있음
- 자동직렬화
  - 스프링은 내부적으로 Jackson 라이브러리를 사용해 자바 객체를 JSON으로 변환함
  - 메서드에서 자바 객체를 반환하면 스프링은 이를 JSON으로 자동 직렬화하여 클라이언트에게 전송함
  - 별도의 변환 작업 없이 자바 객체를 반환하면 스프링이 알아서 JSON 응답으로 만들어줌
4. @GetMapping
  - 스프링 프레임워크에서 HTTP GET 요청을 처리하기 위한 애노테이션이임
  - 특정 URL 경로로 들어오는 GET 요청을 처리하고, 그 요청에 대한 응답을 반환하는 데 사용됨
5. @GetMapping_주요 기능
  - HTTP GET 요청 처리
  - @GetMapping은 HTTP GET 요청을 처리하는 데 사용됨
  - GET 요청은 주로 데이터를 조회하는 용도로 사용되며, 서버에서 데이터를 가져와 클라이언트에 반환하는 역할을 함
  - 예를 들어, 브라우저에서 URL을 입력하고 엔터를 누르면, 
 브라우저는 서버에 GET 요청을 보내 해당 URL에 해당하는 자원을 요청하게 됨
  - 간편한 URL 매핑
  - @GetMapping 어노테이션은 특정 URL 경로와 컨트롤러의 메서드를 쉽게 매핑시켜줌
  - 이렇게 하면 해당 URL로 들어오는 GET 요청이 해당 메서드에 의해 처리됨

6. @PathVariable
  - 스프링 프레임워크에서 URL 경로의 일부를 변수로 사용할 수 있도록 지원하는 애노테이션임
  - 주로 RESTful API에서 사용되며, URL에 포함된 값을 동적으로 받아와 메서드의 매개변수로 사용할 수 있게 해줌
7. @PathVariable_주요기능
  - 동적 경로 처리
  - URL 경로의 일부분을 변수로 받아올 수 있어서 동적 URL을 처리할 수 있음.
  <br>예를 들어, /users/1과 같은 경로에서 1을 변수로 받아서 해당 사용자에 대한 정보를 처리할 수 있음
  - 이를 통해 RESTful API 설계에서 리소스 식별자(ID) 같은 정보를 URL 경로에 포함시켜 처리할 수 있음
  - 매개변수와 URL 매핑 : 
  <br>->컨트롤러 메서드의 매개변수에 @PathVariable을 붙여 URL 경로와 일치하는 값을 받아올 수 있음 -> 이는 GET, POST, PUT, DELETE 등의 요청에서 유용하게 사용됨
8. @PathVariable_주요 속성
  - value : 경로 변수의 이름을 지정함 -> 만약 메서드 매개변수 이름과 경로 변수 이름이 동일하면 생략할 수 있음
  - required : 기본값은 true이며, 경로 변수 값이 반드시 있어야 한다는 의미
 	<br>->단, @PathVariable은 경로에 있는 값을 매핑하는 것이므로, 일반적으로 required = false를 잘 사용하지 않음
	<br>->required = false가 나와도 오류를 발생시키진 않음

### @RequestParam

1. HTTP 요청의 쿼리 파라미터나 폼 데이터를 처리하기 위해 사용되는 애노테이션임
2. 클라이언트가 서버에 요청을 보낼 때, URL 뒤에 붙이는 쿼리 스트링이나 폼 데이터를 받아서 
메서드의 파라미터로 전달할 수 있게 해줌
3. 주요기능
  - 쿼리 파라미터 처리
    1. @RequestParam은 URL 뒤에 붙는 쿼리 파라미터(예: ?key=value)를 메서드의 파라미터로 매핑할 수 있게 해줌
    2. 클라이언트가 요청을 보낼 때 특정 데이터를 쿼리 스트링으로 전달하면, 해당 데이터를 서버에서 쉽게 처리할 수 있음
  - 폼 데이터 처리
    1. POST 요청의 폼 데이터도 @RequestParam을 통해 처리할 수 있음
    2. 사용자가 폼을 통해 입력한 데이터를 서버에서 받는 방식임
4. 사용방법 -> 기본 사용법 (쿼리 파라미터)
  1. 클라이언트가 GET /users?id=1로 요청을 보낼 때, 쿼리 파라미터 id 값을 받아서 userId 변수에 할당함
  - 예를 들어, GET /users?id=1 요청을 보내면 "User ID: 1"이라는 응답이 반환됨
  - 기본값 설정
    - @RequestParam의 파라미터가 선택적일 때, 기본값을 설정할 수 있음
    - 클라이언트가 해당 파라미터를 생략했을 때 기본값이 적용됨
    - defaultValue를 사용하면, 파라미터가 제공되지 않았을 때 기본값이 사용됨
    - 이 예시에서는 GET /users로 요청할 때, 기본값인 0이 userId에 할당됨
  3. 파라미터가 필수인지 설정(required)기본적으로 @RequestParam은 필수임
    - 쿼리 파라미터가 포함되지 않으면 400 Bad Rquest 오류가 발생함
    - 하지만 required = false로 설정하면 해당 . 라미터가 선택적으로 처리됨
    - required = false로 설정하면, 파라미터가 제공되지 않아도 오류가 발생하지 않음
    - 이 경우 userId가 null이 될 수 있음
5. 여러 파라미터 처리 : 
<br>->GET /search?query=spring&page=2로 요청을 보내면 "Search query: spring, Page: 2"라는 응답이 반환됨

6. 폼 데이터 처리(POST요청) : 
- @RequestParam은 GET 요청뿐만 아니라 POST 요청에서 폼 데이터를 처리하는 데도 사용할 수 있음
- 이 경우, 클라이언트가 HTML 폼을 통해 입력한 데이터를 서버에서 받을 수 있음
- 클라이언트가 POST 요청을 통해 name과 email을 보내면, 서버는 해당 데이터를 @questParam을 통해 받아 처리할 수 있음
7. 주요속성
  - required : 파라미터의 필수 여부를 지정함
  - 기본값은 true로, 필수 파라미터가 제공되지 않으면 오류가 발생함
  - required = false로 설정하면 선택적으로 받을 수 있음
  - defaultValue : 파라미터가 제공되지 않을 때 사용할 기본값을 지정함
  - 기본값이 설정된 경우 required = false로 처리됨


### @RequestParam과 @PathVariable의 차이점
1. RequestParam
  - 주로 쿼리 파라미터(URL의 ? 뒤에 오는 값)를 처리함
  - 또한, POST 요청에서 폼 데이터도 처리할 수 있음
  - 예: /users?id
2. @PathVariable
  - URL 경로의 일부로 전달되는 변수를 처리함
  - 주로 RESTful API에서 리소스를 식별하기 위해 사용됨
  - 예: /users
3. @RequestBody
  - HTTP 요청의 본문(body)에 담긴 데이터를 자바 객체로 변환하여 컨트롤러 메서드의 매개변수로 전달하는데 사용하는 애노테이션임
  - 주로POST, PUT, PATCH 요청에서 사용되며, 클라이언트가 전송한 JSON, XML, 또는 폼 데이터 등을 . 자바 객체로 변환하는 역할을 함
4. 주요
  1. HTP 요청 본문 처리
    - @RequestBody는는 클라이언트가 보낸 HTTP 요청의 본문을 읽어와 이를 자바 객체로 변환함
    - 요청 본문은 주로 JSON이나 XML 형식으로 보내지며, 스프링이 이를 자동으로 역직렬화(deserialize)하여 자바 객체로 변환함
  2.  JSON ↔ 자바 객체 변환
  - 스프링은 Jackson 라이브러리를 사용하여 JSON 데이터를 자동으로 자바 객체로 변환할 수 있음
  - 클라이언트가 JSON 데이터를 전송하면, @RequestBody가 이 데이터를 자바 객체로 변환하고, 그 객체를 메서드의 인자로 전달함
5. @ResponseBody
  - 컨트롤러 메서드의 반환 값을 HTTP 응답의 본문(body)에 직접 포함시킬 때 사용됨
  - 뷰(HTML) 같은 템플릿을 반환하는 대신, 주로 JSON, XML, 문자열과 같은 데이터를 클라이언트에게 반환하는 데 사용됨

# ResponseEntity

1. 스프링 프레임워크에서 제공하는 클래스로 HTTP 응답을 보다 세밀하게 제어할 수 있는 방법을 제공함
2. HTTP 상태 코드, 헤더, 그리고 응답 본문을 포함한 전체 HTTP 응답을 구성할 수 있으며, 주로 REST API에서 많이 사용됨
3. 주요기능
  1. HTTP 상태 코드 제어
    - ResponseEntity를 사용하면 클라이언트에 응답할 때, HTTP 상태 코드를 명시적으로 설정할 수 있음
    - 예를 들어, 200 OK, 201 Created, 404 Not Found, 500 Internal Server Error 등의 상태 코드를 쉽게 설정할 수 있음
  2. HTTP 헤더 제어
    - 응답에 HTTP 헤더를 추가하거나 수정할 수 있음
    - 이를 통해 캐시 제어, 인증 정보, 콘텐츠 타입 등을 제어할 수 있음
  3. 응답 본문 제어
    - ResponseEntity는 응답 본문(body)에 객체나 JSON 데이터를 포함할 수 있음
    - 이 객체는 스프링에서 JSON 또는 XML로 직렬화되어 클라이언트에게 반환됨
4. 주요 메서드
  - ResponseEntity.ok(): 200 OK 상태 코드로 응답하는 빌더 메서드
  - ResponseEntity.status(HttpStatus status): 특정 상태 코드를 반환하는 빌더 메서드
  - ResponseEntity.noContent(): 204 No Content 응답을 반환하는 메서드
  - ResponseEntity.badRequest(): 400 Bad Request 응답을 반환하는 메서드
  - ResponseEntity.notFound(): 404 Not Found 응답을 반환하는 메서드
  <br>->우리가 작성할 컨트롤러는 모두 ResponseEntity를 반환할 예정임
5. 정상적으로 응답을 반환한다면 return ResponseEntity.ok().body(response); 라고 뜸


# 서비스 레이어

1. 서비스레이어는 컨트롤러와 퍼시스턴스(영속) 사이에서 비즈니스 로직(서비스를 할 때 필요한 로직)을 수행하는 역할을 함
2. HTTP와 긴밀히 연결된 컨느롤러에서 분리돼 있고, 또 데이터베이스와 긴밀히 연관된 퍼시스턴스와도 분리되어 있음
3. 따라서 서비스 레이어에서는 우리가 개발하고자 하는 로직에 집중할 수 있음
4. @Service
  - 스프링 프레임워크에서 제공하는 애노테이션 중 하나로, **서비스 레이어(Service Layer)**에 사용되는 클래스를 명시할 때 사용됨
  - 이 애노테이션을 사용하면 스프링이 해당 클래스를 **스프링 컨테이너에서 관리하는 빈(bean)**으로 등록하고, 
  비즈니스 로직을 처리하는 역할을 맡음
  - @Component 어노테이션이 붙은 클래스는 Bean으로 만들어주는데, @Service는 @Component 어노테이션의 자식개념으로 볼 수 있음
  - 스프링이 @Service도 찾아서 Bean으로 만들어줌
5. @Component의 자식 컴포넌트 종류
  - @Service
  - @Repository
  - @Controller
  - @RestController
<br>->컴포넌트를 구분함으로써 클래스의 용도를 좀 더 구체적으로 구분할 수 있음

5. @Service_주요기능과 역할
  1. 비즈니스 로직을 담당하는 클래스 표시
    - @Service는 주로 비즈니스 로직을 처리하는 클래스에 붙임
    - 이 클래스는 데이터 액세스, 계산, 트랜잭션 처리 등의 주요 작업을 수행함
    - 서비스 레이어는 **컨트롤러(프레젠테이션 레이어)**와 퍼시스턴스(영속 레이어) 간의 중간 계층으로, 
    복잡한 비즈니스 규칙을 처리하는 데 사용됨
  2. 스프링 빈으로 등록
    - @Service 애노테이션이 붙은 클래스는 **스프링 빈(Bean)**으로 등록되어 **DI(Dependency Injection, 의존성 주입)**를 통해 
    다른 클래스에서 주입(injection)될 수 있음
    - 즉, 스프링은 애플리케이션이 실행될 때 이 클래스의 객체를 생성하고 관리하며, 다른 컴포넌트에서 필요할 때 자동으로 주입해줌
  3. 계층 구조의 명확성
    - @Service는 계층화된 아키텍처에서 서비스 레이어의 역할을 명확하게 구분하는 데 도움을 줌
    - 이를 통해 각 레이어의 책임을 분리하고, 코드의 가독성과 유지보수성을 향상시킴
    - 스프링은 @Service, @Repository, @Controller 등을 통해 각 클래스가 어떤 역할을 하는지 직관적으로 알 수 있게 해줌


# 퍼시스턴스 레이어

<br>스프링 데이터 JPA_관계형 데이터베이스를 자바와 연결하려면 어떻게 해야하는가?

1. DBMS를 설치
2. 테이블을 생성하고 아이템넣기
3. 테이블을 생성하는 것도, 테이블에 엔트리를 추가하는것도, 수정, 삭제하는것도 다 웹 서비스의 일부로 동작해야 함
4. JDBC드라이버를 통해 자바와 연결
  - Connection을 이용해 데이터베이스에 연결하고 쿼리문을 ResultSet클레스에 결과를 담아옴
  - 그리고 While문 내부에서 ResultSet을 Todo객체로 바꿈
  - 이 일련의 작업을 ORM(Object-Relation-Mapping)라고 함
5. 테이블을 자바 내에서 사용하기 위해 이 작업을 엔티티마다 해야함
<br>-> 보통 테이블 하나마다 그에 상응하는 엔티티클래스가 존재함

6. 또 이런 작업을 집중적으로 해주는 DAO클래스를 작성해야 함
7. 시간이 흐르면서 반복작업을 줄이기 위해 Hibernate와 같은 ORM프레임워크가 나왔고, 더 나아가 JPA같은 도구들이 개발됐음
8. 데이터베이스와 스프링 데이터 JPA 설정
  - 데이터베이스에 연결하기 위해서는 데이터베이스가 필요함
  - 우리는 프로젝트를 생성할 때 H2를 추가했었음


# H2 데이터베이스 관리 시스템

1. 자바 기반의 **경량형 관계형 데이터베이스 관리 시스템(RDBMS)**임
2. 주로 개발 및 테스트 환경에서 사용되며, 메모리 기반 데이터베이스나 디스크 기반 데이터베이스로 구성할 수 있음
3. H2는 오픈 소스로 제공되며, 빠르고 가벼운 성능 때문에 애플리케이션 개발 시 간편하게 데이터베이스를 설정하고 사용할 수 있음


14. H2 데이터베이스 관리 시스템_주요 특징

1. 메모리 기반과 디스크 기반 지원
  - 메모리 기반 데이터베이스: 애플리케이션이 실행되는 동안에만 데이터베이스가 유지되며,애플리케이션이 종료되면 데이터가 사라짐 -> 개발 및 테스트에 유용함
  - 디스크 기반 데이터베이스: 데이터가 영구적으로 저장되며, 애플리케이션이 종료되어도 데이터를 유지함
2. 자바 기반
  - H2는 자바로 작성된 데이터베이스 엔진으로, 자바 애플리케이션과의 통합이 매우 용이함
  - JAR 파일로 제공되며, 자바 애플리케이션에서 쉽게 임베드(장착)할 수 있음
3. SQL 표준 지원 : H2는 표준 SQL을 지원하므로, 다른 데이터베이스 시스템(MySQL, PostgreSQL 등)에서 사용되는 SQL 문을 대부분 동일하게 사용할 수 있음
4. 내장형 및 서버 모드
  - 내장형 모드: H2 데이터베이스를 애플리케이션 내부에 임베드하여 사용할 수 있음
 <br>->이 모드에서는 애플리케이션 내에서만 데이터베이스에 접근 가능함
  
  - 서버 모드: H2를 독립된 데이터베이스 서버로 설정하여 네트워크를 통해 여러 클라이언트가 접근할 수 있게 할 수 있음
5. 간편한 설정 및 사용
  - 설정이 매우 간단하며, 스프링 부트와 같은 프레임워크에서 별도의 설정 없이도 인메모리 데이터베이스로 바로 사용할 수 있음
  - 웹 기반의 H2 콘솔(http://localhost:9090/h2-console에 접속하면, SQL 쿼리를 직접 실행하거나 데이터를 조회할 수 있음)을 제공하여, 브라우저를 통해 데이터베이스에 쉽게 접근하고 SQL 쿼리를 실행할 수 있음
6. 빠른 성능 : H2는 메모리 기반으로 동작할 때 매우 빠른 성능을 제공하며, 디스크 기반에서도 경량화된 구조로 효율적인 성능을 제공함


# JPA

1. 자바에서 객체와 관계형 데이터베이스 간의 데이터를 매핑(ORM: Object-Relational Mapping)하기 위한 표준 API임
2. JPA는 자바 객체를 데이터베이스의 테이블과 매핑하고, 데이터베이스의 데이터를 자바 객체로 변환하여 쉽게 다룰 수 있게 해줌
3. 이를 통해 개발자는 데이터베이스의 세부 사항에 구애받지 않고 객체 지향적으로 데이터베이스를 처리할 수 있음
4. 주요 개념 : ORM(Object-Relation Mapping), Persistence Context, Entity
5. ORM(Object-Relation Mapping)
  - JPA는 자바 객체와 데이터베이스의 테이블을 매핑함
  - 자바 객체를 데이터베이스의 테이블로, 객체의 필드를 테이블의 컬럼으로 매핑함으로써, 객체 지향적인 방식으로 데이터베이스 작업을 수행할 수 있음
  - 예를 들어, 데이터베이스의 사용자 테이블을 User 객체와 매핑할 수 있으며, 데이터베이스에 쿼리를 작성하지 않고도 자바 코드로 데이터를 처리할 수 있음
6. Persistence Context
  - JPA에서 엔티티(Entity) 객체를 관리하는 일종의 캐시 역할을 함
  - 이 컨텍스트를 통해 엔티티 객체를 추적하고, 변경된 내용을 자동으로 데이터베이스에 반영함
  - JPA는 객체를 영속성 컨텍스트에서 관리하고, 이를 통해 트랜잭션 내에서 데이터베이스 작업을 처리함
7. Entity
  - JPA에서 관리되는 자바 객체를 **엔티티(Entity)**라고 함
  - 엔티티 클래스는 데이터베이스의 테이블과 매핑되며, 객체의 속성은 테이블의 컬럼과 매핑됨
  - 엔티티 클래스는 @Entity 애노테이션을 통해 정의됨


## Spring Data JPA

1. Spring Data 프로젝트의 일부로, **JPA(Java Persistence API)**를 쉽게 사용할 수 있도록 도와주는 Spring 기반의 데이터 액세스 프레임워크임
2. Spring Data JPA는 Repository 패턴을 기반으로 하여, 데이터베이스와 상호작용할 때 개발자가 반복적으로 작성해야 하는 코드들을 자동으로 처리해줌
3. 주요특징 : Repository 기반 데이터 액세스, 자동화된 CRUD 작업, 쿼리 메서드(Query Method)
4. Repository 기반 데이터 액세스
  - Spring Data JPA는 Repository 인터페이스를 기반으로 데이터베이스에 접근함
  - 이 인터페이스를 확장함으로써 복잡한 데이터 액세스 코드를 작성하지 않고도 CRUD(Create, Read, Update, Delete) 작업을 자동으로 처리할 수 있음
5. 자동화된 CRUD 작업
  - Spring Data JPA는 기본적인 CRUD 메서드를 자동으로 제공함
  - findAll( ), save( ), delete( )와 같은 메서드를 별도의 구현 없이 바로 사용할 수 있음
6. 쿼리 메서드(Query Method)
  - JPA 쿼리 메서드를 작성할 때 메서드 이름만으로 SQL 쿼리를 자동 생성할 수 있음
  - 메서드 이름을 분석하여 해당 메서드에 맞는 SQL 문을 실행함
  - 예를 들어, findByUsername(String username) 메서드는 자동으로 SELECT * FROM User WHERE username = ? 쿼리를 실행함


### 실습

1. 스프링이 Bean을 만들어서 저장함 -> 사용자는 만들어진 Bean을 사용함
2. 객체를 계속 만드는 것이 아닌, 한번 만들어진 객체를 계속 하는 것 -> 싱글톤 패턴
3. 스프링에서 Bean으로 만드는 것들은 다 싱글톤으로 만들어짐
4. 메모리에 딱 한번만 올라가게 되고, 우리는 만들어진 것을 사용함
5. 서비스 개발 실습
  - POST로 요청했을 때 CREATE PEST API 개발
  - GET으로 요청했을 때 RETRIEVE(검색) REST API 개발
  - UPDATE로 요청했을 때 UPDATE REST API 개발
  - DELETE로 요청했을 때 DELETE REST API 개발
6. 영속계층 -> 서비스계층 -> 표현계층 순으로 구현


