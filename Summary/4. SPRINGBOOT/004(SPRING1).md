# 제어역전 실습

1. 제어역전 : 
기존에는 객체는 원하는 시점에 'new 생성자'를 사용해서 객체생성
<br>-> 스프링부트는 시작할때 메모리에 객체를 미리 세팅
<br>-> 그래서 함수를 실행해야만 객체가 생성됨

2. 변경에 유리한 코드1 - 다형성,factory method
3. 변경에 유리한 코드2 - Map과 외부파일(이론) : key = value를 사용, Object를 이용하면 형변환 필요 없음
4. 객체 컨테이너(ApplicationContext)만들기
	- 스프링부트에서 사용함
	- ApplicationCeontext -> 객체 저장소라고 함 : 클래스 안에 Map으로 객체를 저장함
	- AppContext라는 클래스 생성 -> map이라는 객체저장소를 만듦 -> AppContext( )라는 생성자를 정의함
	<br>->new생성자를 통한 객체 생성과 저장 -> key를 매개변수로 전달 -> key에 담겨있는 value 즉, 객체를 반환 -> 저장된 내용을 Map에 저장
5. 객체 자동 등록하기
	- ComponentScanning :  클래스 앞에 @Component 어노테이션을 붙이고, 패키지에 컴포넌트 어노테이션이 붙어있는 클래스를 찾아서 객체로 만들어 Map형태로 저장하는 기법임
6. 객체 찾기
7. 객체를 자동 연결하기

## 의존성 주입을 할 수 있는 방법

1. @Autowired를 붙임 : 순환참조시 오류가 발생하지 않기때문에 stackOverflow가 일어날 수 있음

*순환참조 : Bean간에 참조관계가 순환되어 발생하는 상황임
<br>ex. A클래스가 B클래스의 빈을 주입받고, B클래스가 A클래서의 빈을 주입받는 상황

2. 생성자를 주입(Constructor injection)
```JAVA
class Person{
	String name;
	int age;	
}

public Person(String name, int age){
	this.name = name;
	this.age = age;}
//->이게 생성자를 주입하는 방식

//멤버가 있을 때
public 생성자(멤버){
	this.멤버 = 멤버;	
}
```
3. setter주입(setter injection) :  setter메서드를 통해 객체를 주입받음
4. 하지만 대부분 생성자주입만 사용함

### 의존성 주입_스프링(부트)이 객체를 어떻게 저장하는가?

1. @SpringBootApplication 어노테이션이 속해있는 @ComponentScan어노테이션이 해당파일 아래 경로에 있는 모든 패키지를 탐색하면서 @Component 어노테이션이 붙어있는 클래스를 모두 Map형태로 저장함
2. 클래스 이름의 첫글자를 소문자화해서 key로 저장함
<br>예시 : Computer -> computer 객체를 value로 만들어서 저장함

3. 의존성 주입(Dependency Injection) : 객체를 필요로할 때 스프링이 자동으로 주입해줌
4. 주입받는 방법 : 필드주입(@Autowired붙임), 생성자주입(거의 이방법사용), setter주입

## Gradle

1. Gradle은 자바, 코틀린, 그루비(Groovy) 등 다양한 프로그래밍 언어를 지원하는 빌드 자동화 도구임
2. Gradle은 의존성 관리, 테스트 실행, 배포, 패키징 등의 빌드 작업을 자동화하며, 유연성과 확장성을 중시함
3. 특히 멀티 프로젝트 빌드와 병렬 빌드에 강력한 성능을 발휘하며, 자바 기반 프로젝트에서는 Maven이나 Ant의 대안으로 많이 사용됨
4. Gradle의 주요 특징 : 의존성 관리, DSL, 멀티 프로젝트 빌드, 병렬 빌드, 플러그인 시스템, 유연성
5. 의존성 관리
	- Gradle은 Maven Central, JCenter, Ivy 같은 의존성 저장소에서 외부 라이브러리를 쉽게 가져와 사용할 수 있도록 도와줌
	- 이를 통해 개발자는 필요한 라이브러리를 직접 다운로드하지 않고, 빌드 시 자동으로 라이브러리를 다운로드하고 관리할 수 있음
6. DSL (Domain-Specific Language)
	- Gradle은 빌드 스크립트를 작성할 때 그루비(Groovy) 또는 코틀린(Kotlin) 기반의 DSL을 사용함
	- 이 DSL을 사용해 빌드 로직을 간결하고 유연하게 작성할 수 있음
	- build.gradle 파일에 그루비 기반으로 빌드 설정을 작성하거나, build.gradle.kts 파일에 코틀린 기반으로 작성할 수 있음
7. 멀티 프로젝트 빌드
	- Gradle은 여러 프로젝트를 하나로 묶어 멀티 프로젝트 빌드를 지원함
	- 대규모 애플리케이션 개발 시 여러 모듈을 독립적으로 빌드하면서, 이들 간의 의존성을 쉽게 관리할 수 있음
8. 병렬 빌드
	- Gradle은 병렬 빌드를 지원하여 여러 작업을 동시에 처리할 수 있음
	- 이를 통해 빌드 시간을 크게 단축할 수 있음
9. 플러그인 시스템
	- Gradle은 다양한 플러그인을 제공하여 빌드 작업을 확장할 수 있음
	- 특히 자바, 스프링 부트, 안드로이드 개발에서 유용한 플러그인이 많이 사용됨
	- 예: java 플러그인, application 플러그인, spring-boot 플러그인, kotlin 플러그인 등
10. 유연성
	- Gradle은 빌드 과정을 매우 세밀하게 제어할 수 있는 유연성을 제공함
	- 필요한 경우 Ant와 같은 다른 빌드 도구와 함께 사용할 수도 있음


### build.gradle

1. 프로젝트의 주요 빌드 설정을 정의하는 파일임 -> 여기에 의존성, 플러그인, 태스크(작업) 등을 정의할 수 있음
2. plugins
	- Gradle에서 빌드 작업을 확장하고 자동화할 수 있도록 해주는 기능임
	- 플러그인을 통해 다양한 기능을 추가할 수 있는데, 프로젝트에 필요한 빌드 작업이나 설정을 플러그인을 통해 쉽게 적용할 수 있음
	- 여러 작업을 미리 정의해둔 기능 모음이라고 생각하면 됨
	```JAVA
	plugins {
		id 'java' 
	//자바 프로젝트에서 필수적인 빌드 작업들을 제공하는 플러그인임
	//자바 코드를 컴파일하고, 테스트 코드를 실행하며, JAR 파일을 생성하는 작업을 자동으로 처리해줌
		id 'org.springframework.boot' version '3.2.10'
	//스프링 부트 관련 종속성을 관리하고, 스프링 부트 애플리케이션을 패키징하거나 실행하는 데 필요한 작업들을 자동으로 제공해줌
		id 'io.spring.dependency-management' version '1.1.6'
	//라이브러리나 플러그인의 의존성 버전을 쉽게 관리하고, 중복된 의존성이나 버전 충돌 문제를 방지해줌
	}
	```

## 롬복(Lombok)

1. @Getter getter 메서드 만들어줌
2. @Setter setter 메서드 만들어줌
3. @NoArgsConstructor : 매개변수 없는 기본생성자
4. @AllArgsConstructor : 모든멤버를 매개변수로 가지는 생성자 생성
5. @RequiredArgsConstructor : final이나 @NonNull인 필드만 매개변수로 갖는 생성자 생성
6. @Data : getter, setter, requiredArgsConstructor, ToString, EqulasAandHashCode를 한번에 정의
7. @Builder : 빌더패턴(.을 사용하는 것)을 사용할 수 있게 해주는 어노테이션임
```JAVA 
@Builder
public class User{
	private String id;
	private String name;
	private String email;
}

User user = User.builder( ).id("1").name("홍길동").email("hong@example.com").build( )
//->값은 전부 다 넣을 수도, 일부만 넣을 수도 있음
```


## 포스트맨 API 테스트

1. REST API는 크게 나눠 URI, HTTP메서드, 요청 매개변수 또는 요청바디로 구분도는데, 이를 브라우저에서 테스팅하는 것에는 한계가 있음
2. 테스트를 한다고 임시로 프론트엔드 UI를 만드는 것은 지속가능한 방법이 아님
3. 사용이 간편하고 직관적인 GUI를 제공하는 포스트맨이라는 프로그램을 사용함
4. 포스트맨을 사용하면 간단히 RESTful API를 테스트 할 수 있음
5. 또 테스트를 저장해 API 스모크 테스팅 용으로 사용할 수 있음
6. 다운경로 : https://www.postman.com/downloads/ -> 로그인없이 사용가능


# 레이어드 아키텍처 패턴

1. 애플리케이션을 구성하는 요소들을 수평으로 나눠 관리하는 것임
2. 레이어로 나눈다는 것은 메서드를 클래스 또는 인터페이스로 쪼개는 것임
3. 이 레이어는 작게는 클래스를 여러 레이어로 나누는 것부터 아주 다른 애플리케이션으로 분리하는 경우까지 범위가 다양함
4. 레이어 사이에는 계층이 있음
5. 레이어는 자기보다 한 단계 하위의 레이어만 사용함
6. 중간 레이어를 섞어 사용하는 경우도 있지만 기본적안 레이어드 아키텍처에서는 상위 레이어가 자신의 바로 하위 레이어를 사용함


## DTO(Data Transition Object)

1. 서비스가 요청을 처리하고 클라이언트로 반환할 때, 모델 자체를 그래도 반환하는 경우는 별로 없음
2. 보통은 데이터를 전달하기 위해 사용하는 객체인 DTO로 변환해 반환함
3. DTO로 변환하여 반환하는 이유 -> 비즈니스 로직을 캡슐화 하기 위함임
	- 대부분의 회사들은 외부인이 자사의 DB의 스키마를 아는 것을 원치 않음
	- 이때 DTO처럼 다른 객체로 바꿔 반환하면 외부 사용자에게 서비스 내부의 로직, DB 구조등을 숨길 수 있음
	<br>-> 클라이언트가 필요한 정보를 모델이 전부 포함하지 않는 경우가 많음

	- 대표적으로 에러 메시지가 있음 -> DB에는 에러메세지가 없는데, 이런 경우 DTO에 포함해서 보냄
	- 만약 서비스 실행 도중 유저 에러가 나면 이 에러 메시지를 어디에 포함해야 하는가?
	- 모델은 서비스 로직과는 관련이 없기 때문에 모델에 담기는 애매함
	- 이런 경우 DTO에 에러 메시지 필드를 선언하고 DTO에 포함하면 됨



11. REST 제약조건_6가지

1. 클라이언트-서버 : 리소스를 관리하는 서버가 존재하고, 다수의 클라이언트가 리소스를 소비하기 위해 네트워크를 통해 서버에 접근하는구조
2. 상태가 없는(Stateless)
	- 클라이언트가 서버에 요청을 보낼 때, 이전 요청의 영향을 받지 않음을 의미함
	- 예를들어 /login으로 로그인 요청을 보내고, 로그인이 되어 다음 페이지인 /page로 넘어갔다고 치자
	- /page로 리소스를 불러올 때, 이전 요청에서 login한 사실을 서버가 알고 있어야 한다면 그것은 Stateful상태(REST위반)가 됨
	- Stateless상태를 유지하려면 서버는 그 사실을 몰라야 함
	- 그렇기 때문에 로그인 상태를 유지하지 못하므로 요청을 보낼때마다 로그인 정보를 함께 보내야 함
	- http는 기본적으로 Stateless 프로토콜임
3. 캐시 가능한 데이터
	- 서버에서 리소스를 반환할 때 캐시가 가능한지 아닌지 명시할 수 있어야 함
	- http에서는 cache-control이라는 헤더에 리소스의 캐시 여부를 명시할 수 있음
*캐시
- 데이터를 빠르게 접근하기 위해 메모리나 디스크에 저장해두는 일종의 임시 저장소
- 캐시는 자주 사용되는 데이터를 임시로 저장해두고, 필요할 때 빠르게 가져다 사용할 수 있는 메커니즘
4. 일관적인 인터페이스
	- 시스템 또는 애플리케이션의 리소스에 접근하기 위한 인터페이스가 일관적이어야 한다는 뜻
	- HTTP메서드 사용의 일관성 : GET POST PUT DELETE
   <br>->이렇게 설계하면 API 사용자들이 다양한 리소스와 상호작용 할 때 동일한 패턴을 예상할 수 있음
	- URI 구조의 일관성
	- URI 경로를 일관되게 설계하는 것도 중요함
	- 리소스의 이름은 복수형으로 일관되게 사용하고, 리소스 간 관계를 표현할 때도 규칙적으로 작성해야 함
	- 응답 형식의 일관성
	- 모든 API의 응답 형식도 일관되게 설계해야 함
	- 예를 들어, 성공 시 HTTP 상태 코드와 JSON 형식의 응답을 동일하게 유지하는 게 좋음
	- 에러가 발생한 경우도 일관된 형식으로 제공함
5. 레이어 시스템
	- 클라이언트가 서버에 요청을 날릴 때, 여러 개의 레이어로 된 서버를 거칠 수 있음
	- 클라이언트는 여러 레이어를 인지하지 않고, 최종 서버에서 오는 응답만 신경 쓰게 됨
	- 클라이언트는 프록시, 캐시, 게이트웨이 등을 거치더라도 서버로부터 오는 결과만 받으면 됨
	- 서버 측에서는 각 레이어가 독립적으로 동작하며, 각각의 레이어가 맡은 역할을 수행해 확장성, 보안성, 성능 최적화가 가능함
	- 코드-온-디맨드(선택사항)
6. 코드-온-디맨드(선택사항) : 서버가 클라이언트에게 실행 가능한 코드를 전송하고, 클라이언트가 해당 코드를 실행할 수 있도록 하는 개념임
7. REST 아키텍처
	- 클라이언트가 우리 서비스를 이용하려면 어떤 형식으로 요청을 보내고 응답을 받는지에 대한 이야기임
	- 클라이언트는 정해진 메서드로 우리 서비스를 이용할 예정임
	- REST 아키텍처 스타일을 따라 설계하고 구현된 서비스를 RESTful 서비스라고 함

*스프링은 우리가 레이어드 아키텍처 패턴이나 REST 아키텍처 스타일을 이용하는데 도움을 주는 어노테이션을 제공함


