3. 서비스 통합

1)현재 독립적으로 동작하는 백엔드 애플리케이션과 독립적으로 동작하는 프론트엔드 애플리케이션이 하나씩 있음

2)이제 두 애플리케이션을 통합해 하나의 기능을 하는 웹 애플리케이션을 완성할 차례임

3)프론트엔드에서 fetch또는 axios를 이용해 Todo아이템을 조회,추가,수정,삭제하는 백엔드 API를 호출하는 코드를 작성함

4)App.js에서 axios로 백엔드 API 호출하기 -> ERROR : 보안을 위해 CORS 헤더 Policy를 위반
 
5)CORS(Cross-Origin Resource Sharing)
1>교차 출처 리소스 공유라는 의미
2>이 개념을 이해하려면 먼저 **출처(origin)**와 브라우저 보안 정책을 알아야 함

6)출처
1>출처는 프로토콜과 호스트주소 그리고 포트번호까지 모두 합친것을 의미함
2>즉, 서버의 위치를 찾아가기 위해 필요한 가장 기본적인 것들을 합쳐놓은 것임

7)동일 출처 정책(Same-Origin Policy)
1>브라우저는 기본적으로 보안을 위해 동일 출처 정책이라는 규칙을 따름
2>같은 출처에서 로드된 웹사이트만 서로 데이터를 주고받을 수 있다는 내용임
3>즉, 웹페이지가 한 출처에서 로드되었을 때, 다른 출처에서 데이터를 요청하는 것을 제한하는 정책임
4>https://www.example.com에서 로드된 웹페이지는 기본적으로 https://api.example.com 같은 
다른 출처에 데이터를 요청할 수 없음
5>이 정책은 보안을 위해 존재하는데, 악의적인 웹사이트가 사용자의 브라우저를 이용해 다른 출처에서 
데이터를 가져오지 못하게 막는 역할을 함



4. CORS

1)Cross-Origin Resource Sharing의 약자로, 출처가 다른 두 웹사이트 간의 데이터 요청을 허용하는 방식을 말함

2)예시
1>A라는 웹사이트(https://www.siteA.com)에서 B라는 서버(https://www.siteB.com)에 데이터를 요청하려고 할 때,
B 서버가 A 사이트의 요청을 허용하는지 확인해야 함
2>B 서버가 A 사이트의 요청을 허용하면, CORS를 통해 데이터 요청이 가능해짐

3)CORS가 필요한 이유
1>오늘날의 웹 애플리케이션은 여러 도메인에서 데이터를 주고받는 경우가 많음
2>프론트엔드는 한 도메인에서 실행되고, 백엔드 서버는 다른 도메인에서 실행되는 경우가 많음
3>동일 출처 정책은 보안을 위해 데이터를 차단하지만, CORS는 허용된 출처에서 데이터를 요청할 수 있도록 함

4)CORS의 동작 방식
1>클라이언트(브라우저) : 사용자가 웹사이트를 방문하면 브라우저는 다른 출처로 데이터 요청을 보냄
2>서버 : 데이터를 요청받은 서버는 해당 요청이 허용된 출처에서 온 것인지 확인함
3>응답
-서버가 CORS 설정을 통해 요청을 허용하면, 브라우저는 데이터를 받을 수 있음
-허용되지 않은 출처에서 요청이 왔다면, 브라우저는 데이터를 차단함

5)CORS를 가능하게 하기 위해 백엔드에서 설정하기

6)WebMvcConfigurer
1>Spring MVC에서 제공하는 인터페이스로, 스프링 MVC의 동작을 커스터마이징할 때 사용
2>스프링은 기본적으로 MVC 동작을 자동으로 설정해주지만, 때로는 프로젝트 요구사항에 맞게 특정 기능을 추가하거나 
수정해야 할 때 WebMvcConfigurer를 구현하여 원하는 설정을 적용할 수 있음

7)주요 기능
1>CORS 설정(Custom CORS Configuration)
-addCorsMappings 메서드를 오버라이드하여 CORS(Cross-Origin Resource Sharing) 규칙을 설정할 수 있음
-이를 통해 특정 도메인에서 오는 요청을 허용하거나, 전체 도메인에서 오는 요청을 제어할 수 있음
2>인터셉터(Interceptors) 추가 : 
인터셉터는 HTTP 요청이 컨트롤러에 도달하기 전후에 실행되며, 요청을 가로채어 로깅, 인증, 권한 확인 등의 작업을 수행할 수 있음


5. 리액트의 렌더링

1)리액트는 브라우저에 보이는 HTML DOM 트리의 다른 버전인 ReactDOM을 가지고 있

2)어떤 이유에서 컴포넌트의 상태가 변하면 ReactDOM은 이를 감지하고 컴포넌트 함수를 다시 호출함으로써 
변경된 부분의 HTML을 바꿔줌

3)HTML이 업데이트되면 우리는 변경된 결과를 눈으로 확인할 수 있음

4)즉, 화면에 보여주는 것을 렌더링이라고 함



6. 무한루프에 빠진 리액트

1)렌더링이 가장 처음 일어나는 순간, 리액트는 ReactDOM트리가 존재하지 않는 상태에서 
처음으로 각 컴포넌트 함수를 호출해 자신의 DOM트리를 구성함

2)애플리케이션에서 가장 처음으로 호출하는 함수는 바로 APP( )임

3)App() 함수를 호출할 때, 함수 내에서 axios를 이용해 Todo API를 호출함

4)axios를 사용한 API 호출은 비동기 호출이기 때문에 API 호출 후 응답이 올 때까지 기다리지 않음

5)기다리지 않고 함수를 반환했으니 Add Todo Here과 같은 입력필드나 + 버튼을 볼 수 있는 것임

6)Todo API 호출이 완료돼 리스트가 반환되면 then()으로 이어진 함수가 차례로 실행됨

7)Todo API 호출이 성공하는 경우 then 함수 체인은 결국 setItem(..)을 부름

8)setItem을 부르면 Item의 상태가 새로 초기화 됨

9)상태가 바뀌었음으로 리액트는 재렌더링을 위해 다시 App()을 호출함

10)API함수를 호출할 때, 함수 내에서 axios를 다시 호출하게 됨

11)이렇게 리액트는 무한루프에 빠지게 됨



7. 확장성을 염두한 코드 작성하기

1)API를 호출하는 주소를 하드코딩 할 수 있지만 실제 도메인을 사용하는 것을 염두에 두면 좋은 방법이 아님

2)설정파일에서 애플리케이션이 사용할 백엔드 URI를 동적으로 가져오도록 구현해 이후 도메인이 바뀌는 경우를 대비해야 함

3)api-config.js 파일 생성하기

4)service폴더 생성하기

5)App.js의 기존 함수들을 ApiService를 이용해 수정

6)Todo Update 수정

7)App.js코드 수정하기

8)Todo.js코드 수정하기

9)체크박스 수정 -> Todo.js코드



8. REST API 인증기법_인증

1)개념 : 사용자가 누구인지 확인하는 과정

2)동작 과정 : 사용자가 제공한 정보(사용자 이름과 비밀번호)를 바탕으로, 시스템이 해당 사용자가 실제로 누구인지 확인하는 단계임

3)방법
1>사용자명과 비밀번호 : 가장 전통적인 인증 방식으로, 사용자가 입력한 비밀번호와 저장된 비밀번호를 비교하여 신원을 확인함
2>다중 요소 인증(MFA) : 비밀번호 외에도 추가적인 인증 수단(예: SMS 코드, 이메일 확인 등)을 사용하여 보안을 강화함
3>생체 인증 : 지문, 안면 인식 등 사용자의 고유한 생체 정보를 이용한 인증 방식
4>OAuth 2.0 소셜 로그인 : 사용자가 페이스북, 구글과 같은 외부 서비스의 계정을 이용해 로그인하는 방식임



9. REST API 인증기법_인가

1)개념
1>사용자가 인증된 후에, 그 사용자가 무엇을 할 수 있는지를 결정하는 과정임
2>특정 자원이나 기능에 접근할 수 있는 권한을 부여하는 절차

2)동작 과정 : 사용자가 인증된 후, 시스템은 사용자의 역할, 권한 등을 바탕으로 사용자가 어떤 자원에 접근할 수 있고, 
	    어떤 작업을 수행할 수 있는지를 결정함

3)방법
1>역할 기반 인가(RBAC, Role-Based Access Control) : 
	사용자는 특정 역할(예: 관리자, 사용자, 게스트 등)에 속하며, 각 역할에 따라 다른 권한이 부여
2>정책 기반 인가(PBAC, Policy-Based Access Control) : 
	미리 설정된 정책에 따라 사용자의 권한이 결정된다. 예를 들어, 특정 시간대에만 자원에 접근할 수 있게 하는 정책
3>권한 기반 인가 : 
	특정 권한(예: 읽기, 쓰기, 삭제 등)에 따라 자원 접근 여부를 결정함


*인증과 인가의 구현은 아키텍처 디자인과 밀접한 관계를 갖음
*우리의 서비스가 확장성이 높더라도 인증과 인가의 확장이 어렵다면 우리의 서비스는 인증과 
  인가 서비스의 확장성에 제약을 받게 됨



10. Basic 인증

1)우리가 구현한 Todo 애플리케이션은 로그인을 제외하면 특별히 상태를 유지해야 할 이유가 없음

2)그래서 REST 아키텍처를 사용하는 것이기도 함

3)상태가 없는 웹 애플리케이션에서 인증을 구현하는 가장 간단한 방법은 모든 HTTP 요청에 아이디와 비밀번호를 같이 보내는 것임

4)이런 방법을 Basic 인증이라고함



11. Basic 인증의 동작 방식

1)클라이언트가 요청을 보냄
	->클라이언트(브라우저 또는 애플리케이션)가 서버에 자원에 대한 요청을 보냄
2)서버가 인증 요구
	->서버는 요청된 자원이 인증이 필요하다고 판단되면, 401 Unauthorized 상태 코드와 함께 인증이 필요하다는 
	  메시지를 반환함
3)클라이언트가 자격 증명을 전송
	->클라이언트는 아이디와 비밀번호를 Base64 인코딩하여 HTTP 요청 헤더에 포함한 뒤 다시 요청을 보냄
4)서버가 인증 확인
	->서버는 전송된 자격 증명을 디코딩하여 사용자가 인증할 수 있는지 확인하고, 
	  자격이 유효하면 요청한 자원에 접근을 허용함
5)Baisc 인증 요청 예시

GET /protected-resource HTTP/1.1
Host: example.com
Authorization: Basic dXNlcm5hbWU6cGFzc3dvcmQ=

->이 HTTP 요청을 수신한 서버는 인코딩된 문자열을 디코딩(↔인코딩)해 아이디와 비밀번호를 찾아낸 후, 
 유저 정보가 저장된 데이터베이스 또는 인증 서버의 레코드와 비교함
->데이터베이스의 레코드가 아이디와 비밀번호와 일치하면 요청 받은 일을 수행하고 아니라면 거부함



12. Basic 인증의 장단점

1)장점
1>단순하고 구현이 쉬움 : Basic 인증은 다른 복잡한 인증 방식과 비교해 매우 간단하며, 설정과 구현이 쉬운 편임
2>HTTP 표준 : HTTP 프로토콜의 표준에 포함되어 있어 모든 HTTP 클라이언트에서 쉽게 지원됨

2)단점
1>보안 취약점
-Base64는 인코딩일 뿐이지 암호화가 아니기 때문에 사용자 이름과 비밀번호를 쉽게 디코딩할 수 있음(디코딩은 누구나 가능)
-즉, 네트워크 상에서 데이터를 가로챈다면 자격 증명이 쉽게 노출될 수 있음
2>HTTPS가 필수
-Basic 인증을 사용하려면 반드시 **HTTPS(SSL/TLS 암호화)**를 사용해야 함
-그렇지 않으면, 네트워크 상에서 자격 증명이 평문으로 전송되어 탈취 위험이 큼
3>세션 관리가 어려움 : Basic 인증은 상태를 유지하지 않기 때문에, 매 요청마다 인증 정보를 함께 전송해야 함
4>유저를 로그아웃시킬 수 없음
-모든 요청이 일종의 로그인 요청이기 때문임
-여러 디바이스에서 로그인이 가능한 경우 한꺼번에 로그아웃 하거나 디바이스별로 로그아웃 할 수 있는 기능이 있음
5>사용자의 계정 정보가 있는 저장 장소의 경우 인증 서버와 인증 DB에 과부하가 걸릴 확률이 높음



13. Basic 인증의 토큰 기반 인증

1)사용자가 인증에 성공한 후 토큰을 발급받아, 이를 사용해 서버와의 통신에서 인증을 처리하는 방식임

2)이 방식은 세션 기반 인증과 달리, 서버에 사용자의 상태를 저장하지 않고, 
 토큰을 통해 인증을 관리하기 때문에 무상태(Stateless) 방식으로 작동함

3)이는 RESTful API와 같은 분산 시스템에서 많이 사용됨

4)토큰
1>사용자를 구별할 수 있는 문자열임
2>서버가 자기만의 노하우로 토큰을 만들어줌



14. Basic 인증의 토큰 기반 인증_동작 방식

1)사용자가 로그인
1>사용자가 로그인 요청을 서버에 보냄
2>이때 사용자는 일반적으로 사용자명과 비밀번호를 전송함

2)서버가 사용자 인증 : 서버는 사용자명과 비밀번호를 확인하여 사용자가 올바른 자격을 가지고 있는지 확인함
3)토큰 발급
1>인증에 성공하면, 서버는 사용자의 정보 또는 권한을 포함한 토큰을 생성하여 클라이언트에게 반환함
2>이 토큰은 주로 JWT(JSON Web Token) 형식을 사용함

4)클라이언트가 토큰 저장
1>클라이언트는 이 토큰을 브라우저의 로컬 스토리지(Local Storage) 또는 세션 스토리지(Session Storage) 등에 저장함
2>쿠키에 저장하는 경우도 있음

5)토큰을 포함한 요청
1>이후 클라이언트는 서버에 요청을 보낼 때마다 이 토큰을 HTTP 요청 헤더에 포함시켜 인증을 처리함
2>일반적으로 Authorization 헤더에 Bearer <토큰> 형식으로 토큰을 포함함

6)서버가 토큰 검증
1>서버는 클라이언트로부터 전달받은 토큰이 유효한지 확인함
2>토큰이 유효하다면, 서버는 요청을 처리하고 필요한 자원에 접근을 허용함

7)응답 반환 : 서버는 클라이언트에게 요청된 데이터를 반환하거나, 필요한 처리를 수행함

8)Basic인증과 차이점
1>Basic 인증과 다른 점은 아이디와 비밀번호를 매번 네트워크를 통해 전송해야 할 필요가 없어 보안 측면에서 조금 더 안전함
2>또 토큰은 서버가 마음대로 생성할 수 있으므로 사용자의 인가 정보(일반유저, 관리자) 
  또는 유효기간을 다르게 정하거나 임의로 로그아웃 할 수도 있음



15. JSON 웹 토큰(JWT, JSON WEB TOKEN)

1)SON 형식으로 사용자 정보를 저장하고 **서명(Signature)**을 통해 토큰의 무결성을 검증하는 토큰 기반 인증 방식임

2)JWT는 무상태(Stateless) 방식으로, 서버가 사용자 정보를 별도로 저장하지 않고도 클라이언트를 인증할 수 있기 때문에 
 분산 시스템이나 RESTful API에서 많이 사용됨

※ 전자서명이란?
-서명하고 싶은 메시지를 해시함수를 이용해 축약한 후 개인키로 암호화 했을 때 나오는 결과값을 의미함
-해시 함수(Hash Function)는 임의의 크기를 가진 데이터를 고정된 크기의 값으로 변환하는 함수임
-개인 키는 주로 데이터의 암호화 해제 또는 디지털 서명을 만드는 데 사용되며, 오직 소유자만이 알고 있어야 함

3)JWT구조 : 헤더(Header), 페이로드(Payload), 서명(Signature)
	->이 세 부분을 Base64 URL 인코딩으로 인코딩 한 후 마침표로 구분해 하나의 문자열로 합친것이 JWT임

4)인코딩된 토큰을 Base64로 디코딩하면 헤더,페이로드,서명을 분리할 수 있음

5)예시

Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4g
RG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c

(위를 변경하면 아래와 같음)

{
  "alg": "HS256",
  "typ": "JWT"
}.
{
  "sub": "1234567890",
  "iss": "demo app",
  "exp": 1596597657,
  "iat": 1516239022
}.
SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c

6)Header
1>alg: 사용할 해싱 알고리즘. 예를 들어 HS256(HMAC-SHA256)
2>typ: 토큰의 타입, 여기서는 JWT

7)페이로드(Payload)
1>페이로드는 토큰에 담을 **클레임(Claims)**을 포함함
2>클레임은 JWT에서 사용자 또는 시스템과 관련된 정보를 전달하기 위한 데이터임
3>페이로드에는 여러 유형의 클레임이 포함될 수 있음
4>sub : 사용자 ID 또는 주제(subject). 토큰의 주인을 의미함
5>iss : Issuer를 줄인말. 이 토큰을 발행한 주체를 의미함
6>iat : issued at를 줄인말. 토큰이 발행된 날짜와 시간을 의미함
7>exp : expiration을 의미한다. 토큰이 만료되는 시간을 의미함

2024년 10월 07일 : 43일차


1. 지난주 복습

1)프론트엔드 + 백엔드

		요청(request)->			<-응답(response)
클라이언트	<------->		프론트엔드	<------->		백엔드
						fetch( )/		contoroller <-> service <-> repository <-> DB
						axious( )			    @mapping

->특정 유저가 작성한 Todo를 조회(임시 계정을 쓰기 때문에 지금은 의미x)
->추가 : 내가 입력한 데이터를 백엔드까지 보내야 함 -> call함수(주소,메서드,데이터) 사용 -> options로 잡힘

5)JWT(JasonWebToken)
1>클라이언트가 서버에 화면을 요청 -> 서버에서 로그인요청 -> id,pw입력 -> 화면+토큰전달 -> 로그인 -> 토큰
2>id와 비밀번호를 가지고 로그인 할 때 -> 토큰생성 및 발급
3>인증이 필요한 API를 호출할 때 토큰을 같이 보내서 인증받음
4>인증이 필요한 API가 1000개면 -> 인증 1000번 필요함
-> 그래서 스프링부트 시큐리티를 사용해서 인증이 필요할때마다 알아서 처리가 되게 함


